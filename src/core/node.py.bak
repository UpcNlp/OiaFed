"""
通信节点（抽象层）

Node 是通信抽象层，负责：
1. 创建和管理 node_comm 的生命周期
2. 封装底层 node_comm 的通信细节
3. 提供统一的 call/broadcast 接口
4. 提供健康状态查询接口

重要：node_comm 是 Node 的内部实现细节，外部组件不应感知
"""

import asyncio
import time
from typing import Any, Dict, List, Optional, Union, TYPE_CHECKING

if TYPE_CHECKING:
    from comm import CommNode

# 使用新的配置系统
from ..config import (
    NodeConfig,
    TransportConfig,
    GrpcConfig,
    ConnectionRetryConfig,
    config_to_dict,
)


class Node:
    """
    通信节点（抽象层 + comm 管理者）

    职责：
    1. 创建和管理 node_comm 的生命周期
    2. 封装底层 node_comm 的通信细节
    3. 提供统一的 call/broadcast 接口
    4. 提供健康状态查询接口

    重要：node_comm 是 Node 的内部实现细节，外部组件不应感知

    Example:
        # 从 NodeConfig 创建（推荐）
        from federation import load_config

        config = load_config("configs/trainer.yaml")
        node = Node.from_node_config(config)
        await node.initialize()
        await node.start()

        # 从字典创建（向后兼容）
        node = Node({
            "node_id": "trainer",
            "listen": {"port": 50051},
            "transport": {"mode": "grpc"},
        })
    """

    def __init__(self, config: Union[Dict[str, Any], NodeConfig]):
        """
        初始化节点

        Args:
            config: NodeConfig 实例或配置字典，包含：
                - node_id: 节点 ID
                - listen: 监听配置
                - transport: 传输配置（grpc/memory）
                - heartbeat: 心跳配置
                - serialization: 序列化配置
        """
        # 统一处理配置格式
        if isinstance(config, NodeConfig):
            self._node_config = config
            self._config_dict = self._extract_node_comm_config(config)
        else:
            self._node_config = None
            self._config_dict = config

        self._node_id = self._config_dict.get("node_id", "unknown")

        # node_comm 实例（延迟创建）
        self._comm: Optional["CommNode"] = None

        # 状态标志
        self._is_initialized = False
        self._is_started = False

    # ========== 工厂方法 ==========

    @classmethod
    def from_node_config(cls, config: NodeConfig) -> "Node":
        """
        从 NodeConfig 创建节点（推荐方式）

        Args:
            config: NodeConfig 实例

        Returns:
            Node 实例

        Example:
            from federation import load_config

            config = load_config("configs/trainer.yaml")
            node = Node.from_node_config(config)
        """
        return cls(config)

    @classmethod
    def from_dict(cls, config_dict: Dict[str, Any]) -> "Node":
        """
        从字典创建节点（向后兼容）

        Args:
            config_dict: 配置字典

        Returns:
            Node 实例
        """
        return cls(config_dict)

    # ========== 配置提取 ==========

    def _extract_node_comm_config(self, config: NodeConfig) -> Dict[str, Any]:
        """
        从 NodeConfig 提取 node_comm 需要的配置

        Args:
            config: NodeConfig 实例

        Returns:
            node_comm 配置字典
        """
        result = {
            "node_id": config.node_id,
            "default_timeout": config.default_timeout,
            "listen": config.listen,
        }

        # 传输配置
        if config.transport:
            result["transport"] = {
                "mode": config.transport.mode,
                "grpc": {
                    "host": config.transport.grpc.host,
                    "port": config.transport.grpc.port,
                    "max_message_size": config.transport.grpc.max_message_size,
                },
            }

        # 序列化配置
        if config.serialization:
            result["serialization"] = config.serialization

        # 心跳配置
        if config.heartbeat:
            result["heartbeat"] = config.heartbeat

        return result

    # ========== 属性访问器 ==========

    @property
    def node_id(self) -> str:
        """获取节点 ID"""
        return self._node_id

    @property
    def is_initialized(self) -> bool:
        """检查节点是否已初始化"""
        return self._is_initialized

    @property
    def is_started(self) -> bool:
        """检查节点是否已启动"""
        return self._is_started

    @property
    def config(self) -> Union[NodeConfig, Dict[str, Any]]:
        """获取配置对象"""
        return self._node_config if self._node_config else self._config_dict

    @property
    def transport_mode(self) -> str:
        """获取传输模式"""
        if self._node_config:
            return self._node_config.transport.mode
        return self._config_dict.get("transport", {}).get("mode", "memory")

    @property
    def listen_port(self) -> Optional[int]:
        """获取监听端口"""
        if self._node_config and self._node_config.listen:
            return self._node_config.listen.get("port")
        listen = self._config_dict.get("listen", {})
        return listen.get("port") if listen else None

    # ========== 生命周期管理 ==========

    async def initialize(self):
        """
        初始化 Node（创建 node_comm）

        此方法负责：
        1. 根据配置创建 node_comm 实例
        2. 不启动通信（启动在 start() 中）
        """
        if self._is_initialized:
            return

        # 从 node_comm 包导入 Node 类和 NodeConfig
        from ..comm import Node as CommNode, NodeConfig as CommNodeConfig
        from ..comm.config import (
            _parse_transport_config,
            _parse_serialization_config,
            _parse_heartbeat_config,
        )

        # 解析配置（将字典转换为配置对象）
        transport_config = _parse_transport_config(
            self._config_dict.get("transport", {})
        )
        serialization_config = _parse_serialization_config(
            self._config_dict.get("serialization", {})
        )
        heartbeat_config = _parse_heartbeat_config(
            self._config_dict.get("heartbeat", {})
        )

        # 创建 node_comm 的 NodeConfig
        comm_node_config = CommNodeConfig(
            node_id=self._node_id,
            debug=self._config_dict.get("debug", False),
            default_timeout=self._config_dict.get("default_timeout", 30.0),
            advertised_address=self._config_dict.get("advertised_address"),
            listen=self._config_dict.get("listen"),
            transport=transport_config,
            serialization=serialization_config,
            heartbeat=heartbeat_config,
        )

        # 创建 node_comm.Node 实例
        self._comm = CommNode(self._node_id, comm_node_config)

        self._is_initialized = True

    async def start(self):
        """
        启动 Node（启动 node_comm）

        此方法负责：
        1. 启动底层通信（监听端口）
        2. 连接到对等节点
        3. 启动心跳机制
        """
        if not self._is_initialized:
            await self.initialize()

        if self._is_started:
            return

        # 启动 node_comm
        await self._comm.start()

        # 连接到对等节点（如果配置了）
        peers = self._config_dict.get("peers", [])
        if peers:
            await self._connect_to_peers(peers)

        self._is_started = True

    async def stop(self):
        """
        停止 Node（停止 node_comm）

        此方法负责：
        1. 停止心跳
        2. 断开连接
        3. 关闭监听端口
        """
        if not self._is_started:
            return

        if self._comm:
            await self._comm.stop()

        self._is_started = False

    # ========== 事件系统（转发到 node_comm）==========

    def on(self, event: str, handler):
        """
        注册事件处理器（转发到 node_comm）

        Args:
            event: 事件名称（如 "connect", "disconnect"）
            handler: 事件处理函数
        """
        if not self._is_initialized:
            raise RuntimeError("Node is not initialized. Call initialize() first.")

        self._comm.on(event, handler)

    async def _connect_to_peers(self, peers: List[Dict[str, Any]]):
        """
        连接到对等节点

        Args:
            peers: 对等节点列表，格式：
                [
                    {"node_id": "trainer", "host": "localhost", "port": 50051},
                    ...
                ]
        """
        for peer in peers:
            peer_id = peer.get("node_id")
            host = peer.get("host")
            port = peer.get("port")

            try:
                await self._comm.connect_to(peer_id, host, port)
            except Exception as e:
                # 记录错误但不中断（允许部分连接失败）
                print(f"Failed to connect to {peer_id}: {e}")

    # ========== 核心通信接口（封装 node_comm）==========

    async def call(
        self,
        target: str = None,  # 向后兼容旧参数名
        method: str = None,
        payload: Any = None,  # 支持直接传递 payload
        target_id: str = None,  # 新参数名
        timeout: Optional[float] = None,
        *args,
        **kwargs
    ) -> Any:
        """
        调用远程节点的方法

        Args:
            target: 目标节点 ID（旧参数名，向后兼容）
            method: 方法名
            payload: 预打包的 payload（如果提供则直接使用）
            target_id: 目标节点 ID（新参数名）
            timeout: 超时时间（秒）
            *args: 位置参数（仅在 payload 为 None 时使用）
            **kwargs: 关键字参数（仅在 payload 为 None 时使用）

        Returns:
            远程方法返回值
        """
        if not self._is_started:
            raise RuntimeError("Node is not started. Call start() first.")

        # 参数兼容处理
        actual_target = target_id or target
        if not actual_target:
            raise ValueError("target_id or target must be provided")

        # 直接转发 payload（PeerProxy 已经打包好了）
        return await self._comm.call(
            actual_target,
            method,
            payload,
            timeout=timeout,
        )

    async def broadcast(
        self,
        target_ids: List[str],
        method: str,
        *args,
        **kwargs
    ) -> Dict[str, Any]:
        """
        广播调用多个节点

        Args:
            target_ids: 目标节点 ID 列表
            method: 方法名
            *args: 位置参数
            **kwargs: 关键字参数

        Returns:
            {node_id: result, ...}
        """
        if not self._is_started:
            raise RuntimeError("Node is not started. Call start() first.")

        # 并发调用所有目标节点
        tasks = [
            self.call(target_id, method, *args, **kwargs)
            for target_id in target_ids
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        return dict(zip(target_ids, results))

    # ========== 处理器绑定接口 ==========

    def bind_handler(self, namespace: str, handler: Any):
        """
        绑定请求处理器（如 Learner 实例）

        Args:
            namespace: 命名空间（如 "default"）
            handler: 处理器对象（必须有相应的方法）
        """
        if not self._is_initialized:
            raise RuntimeError("Node is not initialized. Call initialize() first.")

        self._comm.bind(handler, name=namespace)

    def bind(self, handler: Any, name: str = "service"):
        """
        bind 别名，兼容 FederatedSystem 调用

        Args:
            handler: 服务处理对象
            name: 服务名称（命名空间）
        """
        self.bind_handler(name, handler)

    def register(self, method_name: str, handler: Any):
        """
        注册单个方法处理器

        Args:
            method_name: 方法名
            handler: 方法处理函数
        """
        if not self._is_initialized:
            raise RuntimeError("Node is not initialized. Call initialize() first.")

        self._comm.register(method_name, handler)

    async def connect(
        self,
        target_id: str,
        address: Optional[str] = None,
        retry_config: Optional[Dict[str, Any]] = None,
    ):
        """
        连接到远程节点

        Args:
            target_id: 目标节点 ID
            address: 连接地址（Memory 模式下可选）
            retry_config: 重试配置字典或 ConnectionRetryConfig
        """
        if not self._is_started:
            raise RuntimeError("Node is not started. Call start() first.")

        # 转发到 node_comm
        await self._comm.connect(target_id, address, retry_config=retry_config)

    async def wait_for_connections(self, min_peers: int, timeout: float = 120):
        """
        等待足够数量的对等节点连接

        Args:
            min_peers: 最小连接数
            timeout: 超时时间（秒）
        """
        if not self._is_started:
            raise RuntimeError("Node is not started. Call start() first.")

        await self._comm.wait_for_connections(min_peers, timeout)

    def get_connected_nodes(self) -> List[str]:
        """
        获取已连接的节点 ID 列表

        Returns:
            节点 ID 列表
        """
        return self.get_connected_peers()

    # ========== 健康状态查询接口 ==========

    def get_peer_health(self, peer_id: str) -> Dict[str, Any]:
        """
        获取对等节点的健康状态

        Args:
            peer_id: 对等节点 ID

        Returns:
            健康信息字典：
            {
                "status": "healthy" / "unhealthy" / "unknown",
                "last_heartbeat": timestamp,
                "latency_ms": float
            }
        """
        if not self._is_started:
            return {"status": "unknown", "reason": "node_not_started"}

        # 从 node_comm 的 Transport 查询
        transport = self._comm._transport

        if not hasattr(transport, "get_peer_status"):
            # Transport 不支持心跳（如 memory mode）
            return {"status": "unknown", "reason": "transport_no_heartbeat"}

        # 查询 Transport 状态
        peer_status = transport.get_peer_status(peer_id)

        # 获取最后心跳时间
        last_hb = 0
        if hasattr(transport, "_state"):
            last_hb = transport._state.get("last_heartbeat", {}).get(peer_id, 0)

        # 计算延迟
        latency = (time.time() - last_hb) * 1000 if last_hb > 0 else -1

        return {
            "status": peer_status.get("health", "unknown"),
            "last_heartbeat": last_hb,
            "latency_ms": latency,
        }

    def get_all_peers_health(self) -> Dict[str, Dict[str, Any]]:
        """获取所有对等节点的健康状态"""
        if not self._is_started:
            return {}

        peers = self.get_connected_peers()
        return {peer_id: self.get_peer_health(peer_id) for peer_id in peers}

    # ========== 连接管理接口 ==========

    def get_connected_peers(self) -> List[str]:
        """获取已连接的对等节点 ID 列表"""
        if not self._is_started:
            return []

        return self._comm.get_connected_nodes()

    def is_connected(self, peer_id: str) -> bool:
        """检查是否已连接到指定节点"""
        return peer_id in self.get_connected_peers()

    # ========== 调试信息 ==========

    def get_info(self) -> Dict[str, Any]:
        """
        获取节点信息

        Returns:
            节点信息字典
        """
        return {
            "node_id": self._node_id,
            "transport_mode": self.transport_mode,
            "listen_port": self.listen_port,
            "is_initialized": self._is_initialized,
            "is_started": self._is_started,
            "connected_peers": self.get_connected_peers() if self._is_started else [],
        }

    def __repr__(self) -> str:
        """字符串表示"""
        status = "started" if self._is_started else ("initialized" if self._is_initialized else "created")
        return f"Node(id={self._node_id}, mode={self.transport_mode}, status={status})"
