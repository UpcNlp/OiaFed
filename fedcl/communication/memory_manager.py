"""
MOE-FedCL Memoryæ¨¡å¼é€šä¿¡ç®¡ç†å™¨
moe_fedcl/communication/memory_manager.py
"""

import asyncio
from datetime import datetime
from dataclasses import asdict
from typing import Dict, Any

from .base import CommunicationManagerBase
from ..exceptions import RegistrationError
from ..transport.memory import MemoryTransport
from ..types import (
    ClientInfo, RegistrationRequest, RegistrationResponse,
    HeartbeatMessage, CommunicationConfig, RegistrationStatus
)
from ..exceptions import RegistrationError
from ..utils.auto_logger import get_comm_logger

class MemoryCommunicationManager(CommunicationManagerBase):
    """Memoryæ¨¡å¼é€šä¿¡ç®¡ç†å™¨ - åŒè¿›ç¨‹å†…å…±äº«çŠ¶æ€ç®¡ç†"""

    # å…¨å±€å…±äº«çš„å®¢æˆ·ç«¯æ³¨å†Œè¡¨ï¼ˆåªæœ‰ Server ä½¿ç”¨ï¼‰
    _global_client_registry: Dict[str, ClientInfo] = {}

    def __init__(self, node_id: str, transport: MemoryTransport, config: CommunicationConfig, node_role: str = None):
        super().__init__(node_id, transport, config, node_role)
        self.logger = get_comm_logger(node_id)
        # Memoryæ¨¡å¼ä¸‹ä½¿ç”¨å…¨å±€å…±äº«çŠ¶æ€ï¼ˆåªæœ‰ Server ç«¯ï¼‰
        if self.node_role == "server":
            self.clients = self._global_client_registry

    async def register_client(self, registration: RegistrationRequest) -> RegistrationResponse:
        """æ³¨å†Œå®¢æˆ·ç«¯ - Memoryæ¨¡å¼

        æ ¹æ®èŠ‚ç‚¹è§’è‰²åŒºåˆ†è¡Œä¸ºï¼š
        - Client ç«¯ï¼šé€šè¿‡ transport å‘é€æ³¨å†Œè¯·æ±‚åˆ° Server
        - Server ç«¯ï¼šå¤„ç†æ³¨å†Œè¯·æ±‚å¹¶ä¿å­˜å®¢æˆ·ç«¯ä¿¡æ¯
        """
        try:
            client_id = registration.client_id

            # === Client ç«¯è¡Œä¸ºï¼šå‘é€æ³¨å†Œè¯·æ±‚ ===
            if self.node_role == "client":
                # Memoryæ¨¡å¼ä¸‹ï¼Œå®¢æˆ·ç«¯é€šè¿‡ transport å‘é€æ³¨å†Œè¯·æ±‚åˆ°æœåŠ¡ç«¯
                # ä½¿ç”¨é€šç”¨åˆ«å "server"ï¼ˆæœåŠ¡ç«¯ä¼šåŒæ—¶æ³¨å†Œåˆ°å®é™…IDå’Œåˆ«åï¼‰
                server_target = self._get_server_target()

                self.logger.debug(f"[Client {self.node_id}] å‘æœåŠ¡ç«¯å‘é€æ³¨å†Œè¯·æ±‚ï¼Œç›®æ ‡: {server_target}")

                response_data = await self.transport.send(
                    self.node_id,
                    server_target,
                    {
                        "message_type": "registration",
                        "data": {
                            "client_id": client_id,
                            "client_type": registration.client_type,
                            "capabilities": registration.capabilities,
                            "metadata": registration.metadata
                        }
                    }
                )

                self.logger.debug(f"[Client {self.node_id}] æ”¶åˆ°æ³¨å†Œå“åº”: {response_data}")

                # è§£æå“åº”
                return RegistrationResponse(**response_data) if isinstance(response_data, dict) else RegistrationResponse(success=False, client_id=client_id, error_message="Invalid response")

            # === Server ç«¯è¡Œä¸ºï¼šå¤„ç†æ³¨å†Œè¯·æ±‚ ===
            self.logger.debug(f"[Server {self.node_id}] å¤„ç†å®¢æˆ·ç«¯æ³¨å†Œè¯·æ±‚: {client_id}")

            # æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ
            if client_id in self.clients:
                return RegistrationResponse(
                    success=False,
                    client_id=client_id,
                    error_message=f"Client {client_id} already registered"
                )

            # å§”æ‰˜ç»™æ³¨å†ŒæœåŠ¡å¤„ç†
            response = await self.registry_service.register_client(registration)

            # å¦‚æœæ³¨å†ŒæˆåŠŸï¼ŒåŒæ­¥åˆ°æœ¬åœ°çŠ¶æ€
            if response.success:
                client_info = await self.registry_service.get_client_info(client_id)
                if client_info:
                    async with self._lock:
                        self.clients[client_id] = client_info
                        self.heartbeat_status[client_id] = datetime.now()

                    self.logger.info(f"[Server {self.node_id}] å®¢æˆ·ç«¯ {client_id} æ³¨å†ŒæˆåŠŸ")

                # è§¦å‘å®¢æˆ·ç«¯æ³¨å†Œäº‹ä»¶
                await self.transport.push_event(
                    self.node_id,
                    "system",
                    "CLIENT_REGISTERED",
                    {"client_id": client_id, "client_info": client_info}
                )

            return response

        except Exception as e:
            self.logger.exception(f"Client registration failed: {e}")
            raise RegistrationError(f"Client registration failed: {str(e)}")

    def _get_server_target(self) -> str:
        """è·å–æœåŠ¡ç«¯ç›®æ ‡ID

        Returns:
            str: æœåŠ¡ç«¯IDæˆ–åˆ«å
        """
        # å¯ä»¥ä»é…ç½®ä¸­è¯»å–ï¼Œæˆ–ä½¿ç”¨é»˜è®¤åˆ«å
        if hasattr(self.config, 'server_id') and self.config.server_id:
            return self.config.server_id
        # é»˜è®¤ä½¿ç”¨é€šç”¨åˆ«å
        return "server"
    
    async def unregister_client(self, client_id: str) -> bool:
        """æ³¨é”€å®¢æˆ·ç«¯"""
        try:
            async with self._lock:
                # æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å­˜åœ¨
                if client_id not in self.clients:
                    return False
                
                # ç§»é™¤å®¢æˆ·ç«¯
                del self.clients[client_id]
                
                # ç§»é™¤å¿ƒè·³çŠ¶æ€
                if client_id in self.heartbeat_status:
                    del self.heartbeat_status[client_id]
            
            # è§¦å‘å®¢æˆ·ç«¯æ³¨é”€äº‹ä»¶
            await self.transport.push_event(
                self.node_id,
                "system", 
                "CLIENT_UNREGISTERED",
                {"client_id": client_id, "reason": "manual"}
            )
            
            return True
            
        except Exception as e:
            print(f"Client unregistration failed: {e}")
            return False
    
    async def handle_rpc_request(self, source: str, data: Any) -> Any:
        """å¤„ç†RPCè¯·æ±‚ - Memoryæ¨¡å¼ä¸“ç”¨"""
        try:
            message_type = data.get("message_type", "unknown")
            request_data = data.get("data")
            
            # æ ¹æ®æ¶ˆæ¯ç±»å‹åˆ†å‘å¤„ç†
            if message_type == "registration":
                # å¤„ç†æ³¨å†Œè¯·æ±‚
                registration = RegistrationRequest(**request_data)
                response = await self.register_client(registration)
                # è½¬æ¢ä¸ºå­—å…¸è¿”å›ï¼ˆMemoryæ¨¡å¼RPCä¼ è¾“éœ€è¦dictæ ¼å¼ï¼‰
                return asdict(response)
            
            elif message_type == "heartbeat":
                # å¤„ç†å¿ƒè·³
                heartbeat = HeartbeatMessage(**request_data)
                success = await self.handle_heartbeat(source, heartbeat)
                return {"success": success, "timestamp": datetime.now().isoformat()}
            
            elif message_type in self.message_handlers:
                # è°ƒç”¨æ³¨å†Œçš„å¤„ç†å™¨
                handler = self.message_handlers[message_type]
                if asyncio.iscoroutinefunction(handler):
                    return await handler(source, request_data)
                else:
                    return handler(source, request_data)
            
            else:
                return {"error": f"Unknown message type: {message_type}"}
                
        except Exception as e:
            return {"error": str(e), "timestamp": datetime.now().isoformat()}
    
    async def setup_message_handling(self):
        """è®¾ç½®æ¶ˆæ¯å¤„ç†"""
        # æ³¨å†Œè‡ªèº«çš„RPCå¤„ç†å™¨åˆ°Transport
        if hasattr(self.transport, 'register_request_handler'):
            # æ³¨å†Œåˆ°å®é™…çš„ node_id
            self.transport.register_request_handler(
                self.node_id,
                self.handle_rpc_request
            )

            # å¦‚æœæ˜¯ Server ç«¯ï¼ŒåŒæ—¶æ³¨å†Œåˆ°é€šç”¨åˆ«å "server"
            if self.node_role == "server":
                self.logger.info(f"[MemoryCommunicationManager] Server ç«¯æ³¨å†Œåˆ°åˆ«å 'server'")
                self.transport.register_request_handler(
                    "server",
                    self.handle_rpc_request
                )
                self.logger.info(f"[MemoryCommunicationManager] Server æ³¨å†Œå®Œæˆ: {self.node_id} å’Œ 'server'")
    
    async def send_to_client(self, client_id: str, message_type: str, data: Any) -> Any:
        """å‘æŒ‡å®šå®¢æˆ·ç«¯å‘é€æ¶ˆæ¯ - Memoryæ¨¡å¼å¿«é€Ÿé€šé“"""
        try:
            # æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å­˜åœ¨
            if client_id not in self.clients:
                raise ValueError(f"Client {client_id} not found")
            
            # ç›´æ¥å‘é€æ¶ˆæ¯
            return await self.send_business_message(client_id, message_type, data)
            
        except Exception as e:
            print(f"Send to client {client_id} failed: {e}")
            raise
    
    async def broadcast_to_clients(self, message_type: str, data: Any, client_filter: Dict[str, Any] = None) -> Dict[str, Any]:
        """å¹¿æ’­æ¶ˆæ¯åˆ°å®¢æˆ·ç«¯"""
        results = {}
        
        # è·å–ç›®æ ‡å®¢æˆ·ç«¯åˆ—è¡¨
        if client_filter:
            clients = await self.list_clients(client_filter)
            client_ids = [c.client_id for c in clients]
        else:
            client_ids = list(self.clients.keys())
        
        # å¹¶å‘å‘é€æ¶ˆæ¯
        tasks = []
        for client_id in client_ids:
            task = asyncio.create_task(self.send_to_client(client_id, message_type, data))
            tasks.append((client_id, task))
        
        # æ”¶é›†ç»“æœ
        for client_id, task in tasks:
            try:
                result = await task
                results[client_id] = {"success": True, "result": result}
            except Exception as e:
                results[client_id] = {"success": False, "error": str(e)}
        
        return results
    
    def get_shared_state(self) -> Dict[str, Any]:
        """è·å–å…±äº«çŠ¶æ€ - Memoryæ¨¡å¼è°ƒè¯•ç”¨"""
        return {
            "global_clients": list(self._global_client_registry.keys()),
            "local_clients": list(self.clients.keys()),
            "heartbeat_status": list(self.heartbeat_status.keys()),
            "message_handlers": list(self.message_handlers.keys())
        }
    
    async def simulate_client_activity(self, client_id: str, activity: str, data: Any = None):
        """æ¨¡æ‹Ÿå®¢æˆ·ç«¯æ´»åŠ¨ - Memoryæ¨¡å¼æµ‹è¯•ç”¨"""
        if client_id in self.clients:
            async with self._lock:
                self.clients[client_id].last_seen = datetime.now()
                self.clients[client_id].metadata['last_activity'] = activity
                if data:
                    self.clients[client_id].metadata['activity_data'] = data
                
                # æ›´æ–°å¿ƒè·³çŠ¶æ€
                self.heartbeat_status[client_id] = datetime.now()
    
    async def reset_shared_state(self):
        """é‡ç½®å…±äº«çŠ¶æ€ - æµ‹è¯•æ¸…ç†ç”¨"""
        async with self._lock:
            self._global_client_registry.clear()
            self.heartbeat_status.clear()
            self.message_handlers.clear()

        # æ¸…ç†ä¼ è¾“å±‚çŠ¶æ€
        if hasattr(self.transport, 'clear_queues'):
            self.transport.clear_queues()

    @classmethod
    def clear_global_state(cls):
        """æ¸…ç†å…¨å±€å…±äº«çŠ¶æ€ - ç±»æ–¹æ³•ï¼Œç”¨äºæ¼”ç¤ºæˆ–æµ‹è¯•å¼€å§‹å‰çš„æ¸…ç†

        æ³¨æ„ï¼šè¿™ä¼šæ¸…é™¤æ‰€æœ‰Memoryæ¨¡å¼çš„å…±äº«çŠ¶æ€ï¼Œåœ¨æ¼”ç¤ºå¼€å§‹å‰è°ƒç”¨
        """
        cls._global_client_registry.clear()
        # å¦‚æœéœ€è¦æ¸…ç†Transportçš„å…¨å±€çŠ¶æ€ï¼Œä¹Ÿå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
    
    async def start(self) -> None:
        """å¯åŠ¨Memoryé€šä¿¡ç®¡ç†å™¨"""
        await super().start()

        # è®¾ç½®æ¶ˆæ¯å¤„ç†
        await self.setup_message_handling()

    async def stop(self) -> None:
        """åœæ­¢Memoryé€šä¿¡ç®¡ç†å™¨ - æ¸…ç†å…¨å±€å…±äº«çŠ¶æ€"""
        self.logger.debug(f"[MemoryCommunicationManager] å¼€å§‹åœæ­¢: {self.node_id}, è§’è‰²: {self.node_role}")

        # è°ƒç”¨åŸºç±»çš„stopæ–¹æ³•
        await super().stop()

        # ğŸ¯ å…³é”®ä¿®å¤ï¼šMemoryæ¨¡å¼ä¸‹ï¼Œæ¸…ç†å…¨å±€å…±äº«æ³¨å†Œè¡¨
        if self.node_role == "server":
            self.logger.debug(f"[MemoryCommunicationManager] æ¸…ç†å…¨å±€å®¢æˆ·ç«¯æ³¨å†Œè¡¨ï¼Œå½“å‰æ•°é‡: {len(self._global_client_registry)}")
            self._global_client_registry.clear()
            self.logger.info("âœ“ Global client registry cleared (Memory mode)")

        self.logger.debug(f"[MemoryCommunicationManager] åœæ­¢å®Œæˆ: {self.node_id}")

    async def get_debug_info(self) -> Dict[str, Any]:
        """è·å–è°ƒè¯•ä¿¡æ¯"""
        base_info = await self.get_node_status()
        memory_info = {
            "shared_state": self.get_shared_state(),
            "transport_queues": getattr(self.transport, 'get_queue_status', lambda: {})()
        }
        
        return {**base_info, **memory_info}