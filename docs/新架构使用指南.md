# MOE-FedCL 新架构使用指南

## 概述

MOE-FedCL 现在采用了全新的架构设计，实现了：

- **自动代理管理**：`BaseTrainer` 自动管理 `LearnerProxy`，无需手动传入
- **严格层次分离**：每层只处理自己的职责，避免跨层操作
- **事件驱动通信**：通过事件机制实现层间解耦
- **服务端/客户端管理器**：专门的 `FederationServer` 和 `FederationClient` 管理组件生命周期

## 核心组件

### 服务端架构

```
FederationServer (服务端管理器)
    ├── BaseTrainer (训练逻辑层)
    │   ├── ProxyManager (代理管理器) 
    │   │   └── LearnerProxy (客户端代理)
    │   └── LayerEventHandler (事件处理器)
    ├── BusinessCommunicationLayer (业务通信层)
    ├── FederationCoordinator (协调器)
    └── Communication Stack (通信栈)
        ├── ConnectionManager (连接管理层)
        ├── CommunicationManager (通信管理层)  
        └── Transport (传输层)
```

### 客户端架构

```
FederationClient (客户端管理器)
    ├── BaseLearner (学习器实现)
    ├── LearnerStub (服务端存根)
    └── Communication Stack (通信栈)
        ├── ConnectionManager (连接管理层)
        ├── CommunicationManager (通信管理层)
        └── Transport (传输层)
```

## 快速开始

### 1. 创建自定义学习器

```python
from fedcl.learner.base_learner import BaseLearner
from fedcl.types import TrainingRequest, TrainingResponse, ModelData

class MyLearner(BaseLearner):
    def __init__(self, client_id: str, config: Dict[str, Any], logger=None):
        super().__init__(client_id, config, logger)
        # 初始化你的模型和数据
        
    async def train(self, request: TrainingRequest) -> TrainingResponse:
        # 实现你的训练逻辑
        pass
        
    async def evaluate(self, model_data: ModelData = None) -> Dict[str, Any]:
        # 实现你的评估逻辑
        pass
        
    async def get_model(self) -> ModelData:
        # 返回模型参数
        pass
        
    async def set_model(self, model_data: ModelData) -> bool:
        # 设置模型参数
        pass
        
    def get_data_statistics(self) -> Dict[str, Any]:
        # 返回数据统计信息
        pass
```

### 2. 创建自定义训练器

```python
from fedcl.trainer.base_trainer import BaseTrainer

class MyTrainer(BaseTrainer):
    def __init__(self, config: Dict[str, Any]):
        # 注意：不需要传入 learner_proxies，会自动管理
        super().__init__(config)
        
    async def run_training(self):
        # 获取可用客户端（自动通过ProxyManager管理）
        available_clients = self.get_available_clients()
        
        # 检查客户端是否就绪
        for client_id in available_clients:
            if self.is_client_ready(client_id):
                # 获取代理并发送请求
                proxy = self.proxy_manager.get_proxy(client_id)
                result = await proxy.train(training_request)
```

### 3. 启动服务端

```python
from fedcl.federation.server import FederationServer

# 创建服务端
server_config = {
    "mode": "memory",  # 或 "process", "network"
    "timeout": 30.0
}

server = FederationServer(server_config)

# 初始化训练器
trainer = MyTrainer(trainer_config)
await server.initialize_with_trainer(trainer)

# 启动服务端
await server.start_server()
```

### 4. 启动客户端

```python
from fedcl.federation.client import FederationClient

# 创建客户端
client_config = {
    "mode": "memory",  # 与服务端保持一致
    "timeout": 30.0
}

client = FederationClient.create_client(client_config)

# 初始化学习器
learner = await client.initialize_with_learner(MyLearner, learner_config)

# 启动客户端（自动注册到服务端）
await client.start_client()
```

## 核心特性详解

### 自动代理管理

- **无需手动管理**：`BaseTrainer` 不再需要 `learner_proxies` 参数
- **事件驱动创建**：客户端注册时自动创建对应的 `LearnerProxy`
- **透明访问**：通过 `get_available_clients()` 和 `is_client_ready()` 方法访问

```python
class MyTrainer(BaseTrainer):
    async def my_training_method(self):
        # 自动获取可用客户端
        clients = self.get_available_clients()
        
        for client_id in clients:
            if self.is_client_ready(client_id):
                # 自动获取代理
                proxy = self.proxy_manager.get_proxy(client_id)
                # 使用代理进行远程调用
                result = await proxy.train(request)
```

### 严格层次分离

- **FederationServer**：负责服务端组件生命周期管理
- **FederationClient**：负责客户端组件生命周期管理  
- **BaseTrainer**：只处理训练逻辑，不涉及通信细节
- **FederationCoordinator**：只负责协调，不处理业务逻辑
- **BusinessCommunicationLayer**：处理代理创建和事件传播

### 事件驱动通信

```python
# 客户端注册时的事件流：
1. 客户端 -> 通信层 -> 注册请求
2. 通信层 -> BusinessCommunicationLayer -> 创建LearnerProxy  
3. BusinessCommunicationLayer -> ProxyManager -> 添加代理
4. ProxyManager -> BaseTrainer -> 通知代理可用
```

## 配置选项

### 服务端配置

```python
server_config = {
    "mode": "memory",           # 通信模式：memory/process/network
    "timeout": 30.0,           # 请求超时时间
    "heartbeat_interval": 10.0, # 心跳间隔
    "trainer": {               # 训练器特定配置
        "min_clients": 2,
        "max_rounds": 10
    }
}
```

### 客户端配置

```python
client_config = {
    "mode": "memory",          # 通信模式（与服务端一致）
    "timeout": 30.0,          # 请求超时时间
    "learner": {              # 学习器特定配置
        "batch_size": 32,
        "learning_rate": 0.01
    },
    "stub_config": {          # 存根配置
        "registration_retry_attempts": 3,
        "registration_retry_delay": 1.0
    }
}
```

## 通信模式

### 内存模式 (Memory)
```python
config = {"mode": "memory"}
```
- 适用于单进程内的组件通信
- 最快的通信方式
- 适合原型开发和测试

### 进程模式 (Process)
```python
config = {
    "mode": "process", 
    "port": 8001
}
```
- 适用于同一机器上的多进程通信
- 通过进程间通信机制
- 适合本地分布式测试

### 网络模式 (Network)
```python
config = {
    "mode": "network",
    "host": "localhost", 
    "port": 8001
}
```
- 适用于跨机器的网络通信
- 支持真正的分布式部署
- 适合生产环境

## 生命周期管理

### 服务端生命周期
```python
# 创建 -> 初始化 -> 启动 -> 运行 -> 停止
server = FederationServer(config)
await server.initialize_with_trainer(trainer)
await server.start_server()
# 运行训练...
await server.stop_server()
```

### 客户端生命周期
```python
# 创建 -> 初始化 -> 启动(注册) -> 运行 -> 停止(注销)
client = FederationClient.create_client(config)
await client.initialize_with_learner(LearnerClass, learner_config)
await client.start_client()  # 自动注册
# 参与训练...
await client.stop_client()  # 自动注销
```

## 最佳实践

1. **继承基类**：始终继承 `BaseLearner` 和 `BaseTrainer`
2. **配置一致**：确保服务端和客户端的通信模式配置一致
3. **错误处理**：在训练和评估方法中添加适当的错误处理
4. **资源清理**：使用 `try/finally` 或 `async with` 确保资源正确清理
5. **日志记录**：添加适当的日志记录以便调试

## 示例代码

完整的示例代码请参考：
- `examples/complete_new_architecture_demo.py` - 完整架构演示
- `examples/fedavg_mnist_trainer.py` - FedAvg算法示例
- `examples/mnist_learner.py` - MNIST学习器示例

## 故障排除

### 常见问题

1. **客户端注册失败**
   - 检查通信模式配置是否一致
   - 确认服务端已正确启动
   - 查看注册重试配置

2. **代理未找到**
   - 确认客户端已成功注册
   - 检查客户端ID是否正确
   - 等待代理创建完成

3. **通信超时**
   - 增加timeout配置
   - 检查网络连接
   - 确认请求处理时间

### 调试技巧

1. 启用详细日志输出
2. 使用内存模式进行本地调试
3. 检查组件状态方法：`get_server_status()`, `get_client_status()`
4. 逐步增加客户端数量进行测试
