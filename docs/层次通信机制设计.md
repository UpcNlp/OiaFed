# MOE-FedCL 层次通信机制设计

## 1. 当前系统层次架构

```
┌─────────────────────────────────────────────────────────────────┐
│                    第1层：业务抽象层                             │
│                  ┌─────────────────┐                            │
│                  │   BaseTrainer   │                            │
│                  │ ProxyManager ←──┼─── trainer._proxy_manager   │
│                  │ EventHandler ←──┼─── trainer._proxy_event_handler │
│                  └─────────────────┘                            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ 事件向下：调用learner_proxies
                      │ 事件向上：接收LEARNER_PROXY_READY
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    第2层：业务通信层                             │
│                  ┌─────────────────┐                            │
│                  │BusinessComm     │                            │
│                  │Layer           │                            │
│                  │ - LearnerProxy  │◄─── 代理管理               │
│                  │ - 事件处理      │                            │
│                  └─────────────────┘                            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ 事件向下：CONNECTION_ESTABLISHED
                      │ 事件向上：LEARNER_PROXY_READY  
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    第3层：连接管理层                             │
│                  ┌─────────────────┐                            │
│                  │ConnectionManager│                            │
│                  │ - 连接池管理     │                            │
│                  │ - 消息路由      │                            │
│                  └─────────────────┘                            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ 事件向下：REQUEST/RESPONSE
                      │ 事件向上：CONNECTION_ESTABLISHED
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    第4层：通用通信层                             │
│                  ┌─────────────────┐                            │
│                  │CommunicationMgr │                            │
│                  │ - 客户端注册     │                            │
│                  │ - 心跳保活      │                            │
│                  └─────────────────┘                            │
└─────────────────────┬───────────────────────────────────────────┘
                      │ 数据传输：原始消息
                      │ 事件向上：CLIENT_REGISTERED
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    第5层：传输抽象层                             │
│                  ┌─────────────────┐                            │
│                  │ TransportBase   │                            │
│                  │ - 数据传输      │                            │
│                  │ - 序列化        │                            │
│                  └─────────────────┘                            │
└─────────────────────────────────────────────────────────────────┘
```

## 2. 层间通信规则

### 2.1 事件传递方向

**向上传递事件（Bottom-Up）：**
- 第5层 → 第4层：`DATA_RECEIVED`, `CONNECTION_LOST`
- 第4层 → 第3层：`CLIENT_REGISTERED`, `CLIENT_DISCONNECTED`
- 第3层 → 第2层：`CONNECTION_ESTABLISHED`, `CONNECTION_FAILED`
- 第2层 → 第1层：`LEARNER_PROXY_READY`, `LEARNER_PROXY_DISCONNECTED`

**向下传递调用（Top-Down）：**
- 第1层 → 第2层：通过`learner_proxies`调用业务方法
- 第2层 → 第3层：通过`ConnectionManager`发送消息
- 第3层 → 第4层：通过`CommunicationManager`处理请求
- 第4层 → 第5层：通过`TransportBase`发送数据

### 2.2 严格层次隔离原则

**禁止跨层直接调用：**
- ❌ 第1层直接调用第3、4、5层
- ❌ 第2层直接调用第4、5层  
- ❌ 任何层级跳过中间层

**允许的通信方式：**
- ✅ 相邻层间接口调用
- ✅ 事件向上传递（LayerEventHandler）
- ✅ 依赖注入接口（不直接调用实现）

## 3. 事件驱动通信机制

### 3.1 LayerEventHandler接口

```python
class LayerEventHandler(ABC):
    """层间事件处理接口 - 确保严格的向上传递"""
    
    def __init__(self, upper_layer: Optional['LayerEventHandler'] = None):
        self.upper_layer = upper_layer
    
    @abstractmethod
    def handle_layer_event(self, event_type: str, event_data: Dict[str, Any]):
        """处理本层事件"""
        pass
    
    def propagate_to_upper(self, event_type: str, event_data: Dict[str, Any]):
        """向上层传递事件"""
        if self.upper_layer:
            self.upper_layer.handle_layer_event(event_type, event_data)
    
    def set_upper_layer(self, upper_layer: 'LayerEventHandler'):
        """设置上层处理器"""
        self.upper_layer = upper_layer
```

### 3.2 层级关系建立

```python
# 在FederationServer中建立层级关系
def _establish_layer_relationships(self):
    """建立严格的层级事件传递关系"""
    
    # 第2层 → 第1层：业务通信层向训练器传递事件
    self.business_layer.set_upper_layer(self.trainer._proxy_event_handler)
    
    # 第3层 → 第2层：连接管理层向业务通信层传递事件
    self.connection_manager.set_upper_layer(self.business_layer)
    
    # 第4层事件通过回调转换为第3层事件
    self.communication_manager.registry_service.add_callback(
        'CLIENT_REGISTERED', self._handle_client_registered_event
    )
```

## 4. 具体通信流程

### 4.1 客户端注册流程

```
1. 客户端注册请求
   TransportBase → CommunicationManager
   
2. 注册成功事件  
   CommunicationManager.emit_event("CLIENT_REGISTERED") 
   → 通过回调转换为层级事件
   
3. 连接建立事件
   FederationServer._handle_client_registered_event()
   → ConnectionManager.handle_layer_event("CONNECTION_ESTABLISHED")
   
4. 代理创建事件
   ConnectionManager.propagate_to_upper("CONNECTION_ESTABLISHED") 
   → BusinessCommunicationLayer.handle_layer_event()
   
5. 代理就绪事件
   BusinessCommunicationLayer.propagate_to_upper("LEARNER_PROXY_READY")
   → ProxyManagerEventHandler.handle_layer_event()
   
6. 代理注册完成
   ProxyManager.on_proxy_ready() → 更新trainer.learner_proxies
```

### 4.2 联邦训练流程

```
1. 训练调用
   BaseTrainer.train_round() → learner_proxies[client_id].train()
   
2. 代理转发
   LearnerProxy.train() → BusinessCommunicationLayer.send_message()
   
3. 连接路由
   BusinessCommunicationLayer → ConnectionManager.route_message()
   
4. 通信发送
   ConnectionManager → CommunicationManager.send_request()
   
5. 传输发送
   CommunicationManager → TransportBase.send()
   
6. 结果返回（原路径返回）
   TransportBase → ... → LearnerProxy → BaseTrainer
```

## 5. 当前问题和解决方案

### 5.1 问题：跨层调用

**当前问题：**
- `FederationServer`直接调用`self.business_layer.handle_layer_event()`
- 缺少第3层（ConnectionManager）作为LayerEventHandler

**解决方案：**
1. 让`ConnectionManager`继承`LayerEventHandler`
2. 通过事件回调桥接第4层到第3层
3. 严格遵循事件向上传递原则

### 5.2 问题：事件转换缺失

**当前问题：**
- `CLIENT_REGISTERED`事件无法传递到层级系统
- `RegistryService`的事件系统独立于`LayerEventHandler`

**解决方案：**
1. 在`FederationServer`中注册回调函数
2. 将第4层事件转换为第3层事件
3. 通过`ConnectionManager`向上传递

## 6. 修复计划

### 步骤1：修复ConnectionManager
让`ConnectionManager`继承`LayerEventHandler`，实现严格的层级关系。

### 步骤2：修复事件桥接
在`FederationServer`中实现事件转换，将第4层事件桥接到第3层。

### 步骤3：验证层级隔离
确保没有跨层直接调用，所有通信都通过相邻层接口。

### 步骤4：测试端到端流程
验证客户端注册 → 代理创建 → 联邦训练的完整流程。
