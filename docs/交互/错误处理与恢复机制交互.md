```mermaid
sequenceDiagram
    participant FS as FederatedServer
    participant CM as ClientManager
    participant CommMgr as CommunicationManager
    participant FC1 as FederatedClient1
    participant FC2 as FederatedClient2(故障)
    participant FC3 as FederatedClient3(备用)
    participant MM as ModelManager
    participant CheckM as CheckpointManager
    participant EH as ErrorHandler
    
    Note over FS,EH: 正常训练轮次开始
    
    FS->>CM: select_clients_for_round(3)
    CM-->>FS: [client1, client2, client3]
    
    FS->>CommMgr: broadcast_model([client1, client2])
    par 并行发送模型
        CommMgr->>FC1: send_model(global_model)
        FC1-->>CommMgr: model_received_ack
        and
        CommMgr->>FC2: send_model(global_model)
        Note over FC2: 网络故障！
        CommMgr-xFC2: connection_timeout
    end
    
    Note over CommMgr,EH: 错误检测阶段
    CommMgr->>EH: handle_communication_error(client2, timeout)
    EH->>CM: notify_client_failure(client2)
    
    Note over CM,EH: 故障客户端处理
    CM->>CM: mark_client_as_failed(client2)
    CM->>CM: update_client_health_status()
    
    Note over EH,CM: 恢复策略决策
    EH->>CM: get_replacement_clients(1)
    CM->>CM: select_from_standby_pool()
    CM-->>EH: [client3]
    
    Note over EH,CommMgr: 替换客户端处理
    EH->>CommMgr: add_replacement_client(client3)
    CommMgr->>FC3: send_model(global_model)
    FC3-->>CommMgr: model_received_ack
    
    Note over FC1,FC3: 继续训练（剩余客户端）
    par 剩余客户端训练
        FC1->>FC1: train_local_model()
        FC1->>CommMgr: send_update(update1)
        and
        FC3->>FC3: train_local_model()
        FC3->>CommMgr: send_update(update3)
    end
    
    Note over CommMgr,FS: 聚合调整
    CommMgr->>FS: collect_available_updates([update1, update3])
    FS->>MM: aggregate_partial_updates(updates, missing_clients=[client2])
    
    Note over MM,CheckM: 检查点保存（容错）
    MM->>CheckM: save_checkpoint(round_id, model, metadata)
    CheckM->>CheckM: save_state_to_disk()
    CheckM-->>MM: checkpoint_saved
    
    Note over MM,EH: 聚合策略调整
    MM->>EH: adjust_aggregation_weights(available_clients, failed_clients)
    EH->>EH: compute_adjusted_weights()
    EH-->>MM: adjusted_weights
    
    MM->>MM: weighted_aggregate(updates, adjusted_weights)
    MM-->>FS: aggregation_complete
    
    Note over FS,EH: 故障恢复尝试
    FS->>EH: attempt_client_recovery(client2)
    EH->>CommMgr: ping_client(client2)
    
    alt 客户端恢复成功
        CommMgr->>FC2: health_check()
        FC2-->>CommMgr: client_recovered
        CommMgr-->>EH: client2_back_online
        EH->>CM: restore_client(client2)
        CM->>CM: mark_client_as_active(client2)
        
    else 客户端仍然故障
        CommMgr-xFC2: still_unreachable
        CommMgr-->>EH: client2_still_failed
        EH->>CM: keep_client_in_failed_pool(client2)
        
        Note over EH,CheckM: 考虑实验终止条件
        EH->>EH: check_min_clients_threshold()
        alt 活跃客户端足够
            EH-->>FS: continue_with_remaining_clients
        else 活跃客户端不足
            EH->>CheckM: save_emergency_checkpoint()
            EH-->>FS: pause_experiment_insufficient_clients
        end
    end
    
    Note over FS,CheckM: 下一轮准备或实验暂停
    
    Note over FS,EH: 额外的恢复场景
    
    rect rgb(255, 240, 240)
        Note over FS,EH: 服务端故障恢复场景
        FS-xFS: 服务端崩溃
        Note over CheckM: 检测到服务端故障
        CheckM->>CheckM: auto_recovery_from_latest_checkpoint()
        CheckM->>FS: restore_server_state(checkpoint)
        FS->>CM: rebuild_client_connections()
        CM->>CommMgr: reconnect_to_all_clients()
        CommMgr-->>FS: clients_reconnected
    end
    
    rect rgb(240, 255, 240)
        Note over EH,CommMgr: 网络分区恢复场景  
        CommMgr->>EH: detect_network_partition([client1], [client2, client3])
        EH->>EH: evaluate_partition_severity()
        
        alt 主分区客户端足够
            EH-->>FS: continue_with_main_partition([client1])
        else 需要等待网络恢复
            EH->>CheckM: save_partition_checkpoint()
            EH-->>FS: wait_for_network_healing()
        end
    end