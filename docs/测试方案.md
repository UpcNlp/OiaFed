# MOE-FedCL核心功能测试指导
基于设计文档的5个关键验证点

## 测试总览

**5个核心测试，验证系统核心能力**
```
测试1：三种传输模式基本通信 (第5层)
测试2：客户端注册和心跳机制 (第4层) 
测试3：服务端远程调用客户端训练 (第2层)
测试4：完整联邦学习流程 (第0层)
测试5：三种模式兼容性验证 (集成)
```

---

## 测试1：三种传输模式基本通信

### 验证目标
验证TransportBase抽象接口的send()和receive()方法在三种模式下都能正常工作

### 测试要点
```python
# 关键验证
@pytest.mark.parametrize("mode", ["memory", "process", "network"])
def test_transport_basic_communication(mode):
    """验证基础通信功能"""

验证步骤：
1. 根据模式创建对应的Transport实例
2. 建立连接："memory_server" <-> "memory_client_1" (依据文档第8.2节标识符格式)
3. 发送测试消息：await transport.send("memory_server", "memory_client_1", test_data)  
4. 接收验证：data = await transport.receive("memory_client_1", "memory_server", timeout=5.0)
5. 验证数据完整性：assert data == test_data

三种模式差异验证：
- Memory模式：验证直接对象传递，无序列化
- Process模式：验证pickle序列化，跨进程队列
- Network模式：验证JSON序列化，HTTP传输
```

### 验收标准
```
通过条件：
- 三种模式都返回success=True
- 数据完整性100%正确
- Memory模式延迟 < 1ms，Process < 10ms，Network < 100ms

失败处理：
- 任何模式失败都必须修复后才能继续后续测试
- 检查对应模式的序列化和传输机制
```

---

## 测试2：客户端注册和心跳机制

### 验证目标
验证文档第12.3节"阶段一：系统启动与客户端注册流程"和"阶段二：心跳保活机制流程"

### 测试要点
```python
def test_client_registration_heartbeat():
    """验证完整的客户端生命周期"""

客户端注册流程验证：
1. LearnerStub.start_listening() 触发注册
2. CommunicationManager.register_client() 处理注册
3. 验证RegistrationMessage发送和RegistrationResponse接收
4. 验证客户端状态变为REGISTERED

心跳机制验证：
1. 注册成功后自动启动心跳（间隔30秒）
2. 验证HeartbeatMessage定时发送
3. 服务端CommunicationManager.handle_heartbeat()更新状态
4. 模拟心跳超时，验证CLIENT_DISCONNECTED事件
```

### 验收标准
```
通过条件：
- 客户端注册成功率100%
- 心跳发送接收正常
- 超时检测机制工作
- 客户端状态正确维护

关键检查：
- 文档中定义的RegistrationMessage和HeartbeatMessage格式正确
- 客户端ID按文档标识符规范生成
```

---

## 测试3：服务端远程调用客户端训练

### 验证目标  
验证文档第4.1节"LearnerProxy远程调用模式"和第5.2-5.3节的Proxy/Stub机制

### 测试要点
```python
def test_server_remote_call_client():
    """验证服务端通过learner_proxies调用客户端"""

关键调用链验证：
1. BaseTrainer通过learner_proxies调用：
   result = await self.learner_proxies[client_id].train(params)

2. LearnerProxy封装远程调用：
   - 构造TrainingRequest
   - 调用communication_manager.send_business_message()

3. LearnerStub接收处理：
   - handle_train_request()处理请求
   - 调用本地BaseLearner.train()
   - 封装TrainingResponse返回

4. 验证完整数据流：
   服务端参数 → LearnerProxy → CommunicationManager → TransportBase 
   → LearnerStub → BaseLearner → 训练结果原路返回
```

### 验收标准
```
通过条件：
- 远程调用成功率100%
- 参数传递完整正确
- 训练结果正确返回
- 异常情况正确处理

关键验证：
- learner_proxies字典正确初始化
- 文档定义的TrainingRequest/TrainingResponse格式正确
- 异步调用机制工作正常
```

---

## 测试4：完整联邦学习流程

### 验证目标
验证文档第3.1节FederationCoordinator作为"联邦学习统一入口"的完整流程协调能力

### 测试要点
```python  
def test_complete_federation_flow():
    """验证端到端联邦学习流程"""

完整流程验证（对应文档第12.3节）：
1. 系统初始化：
   - 创建FederationCoordinator
   - 启动2个客户端(MockBaseLearner + LearnerStub)

2. 客户端注册阶段：
   - 所有客户端自动注册到服务端
   - wait_for_clients()等待注册完成
   - 验证get_active_clients()返回正确列表

3. 联邦训练执行：
   - start_federation()启动训练
   - run_training_round(1)执行第一轮
   - 验证所有客户端train()被调用
   - aggregate_models()聚合结果
   - run_training_round(2)执行第二轮

4. 训练结束：
   - stop_federation()停止训练
   - 所有客户端unregister_from_server()
   - 资源清理完整
```

### 验收标准
```
通过条件：
- 完整流程无异常执行
- 2轮训练都成功完成
- 模型聚合逻辑正确
- 资源清理无泄漏

关键验证：
- FederationCoordinator确实作为统一入口工作
- BaseTrainer.learner_proxies调用模式正确
- 文档承诺的"用户只需继承BaseTrainer和BaseLearner"实现
```

---

## 测试5：三种模式兼容性验证

### 验证目标
验证文档承诺的"切换运行模式只需修改配置文件"和"同一套代码支持三种运行模式"

### 测试要点
```python
@pytest.mark.parametrize("mode", ["memory", "process", "network"]) 
def test_mode_compatibility(mode):
    """验证模式兼容性"""

兼容性验证：
1. 使用相同的MockBaseTrainer和MockBaseLearner代码
2. 仅修改配置文件：system.mode = mode
3. 执行完整联邦学习流程
4. 验证三种模式的训练结果逻辑一致

配置切换验证：
- memory.yaml：验证共享内存通信配置
- process.yaml：验证进程间队列配置  
- network.yaml：验证HTTP/WebSocket配置

结果一致性验证：
- 相同输入参数下，三种模式产生相同的聚合模型
- 训练轮次和收敛行为一致
- 仅通信延迟不同，业务逻辑完全一致
```

### 验收标准
```
通过条件：
- 三种模式的端到端流程都成功
- 用户业务代码无需修改
- 配置文件切换即可改变模式
- 训练结果逻辑一致性100%

架构验证：
- 验证文档第1.3节"用户开发模式"的承诺
- 验证分层架构的模式透明性
```

---

## 执行顺序和依赖

### 测试依赖链
```
测试1(传输层) → 测试2(注册心跳) → 测试3(远程调用) → 测试4(端到端) → 测试5(兼容性)

严格顺序：
- 测试1失败 → 停止，修复传输层
- 测试2失败 → 停止，修复通信层  
- 测试3失败 → 停止，修复业务层
- 测试4失败 → 停止，修复协调层
- 测试5失败 → 检查配置和兼容性实现
```

### 执行时间预估
```
测试1：15分钟 (三种传输模式验证)
测试2：10分钟 (注册和心跳机制)
测试3：10分钟 (RPC远程调用)
测试4：15分钟 (端到端流程)
测试5：15分钟 (兼容性验证)

总计：65分钟完成核心功能验证
```

---

## 快速验证命令

### 一键执行所有核心测试
```bash
# 按顺序执行5个核心测试
pytest tests/test_core_1_transport.py -v
pytest tests/test_core_2_registration.py -v  
pytest tests/test_core_3_remote_call.py -v
pytest tests/test_core_4_end_to_end.py -v
pytest tests/test_core_5_compatibility.py -v

# 或一次性执行
pytest tests/test_core_*.py -v --tb=short
```

### 成功标志
```
全部测试PASSED = 核心功能完整可用

具体标志：
✓ 三种传输模式都能发送接收消息
✓ 客户端能成功注册并维持心跳  
✓ 服务端能远程调用客户端训练方法
✓ 完整联邦学习流程可以执行
✓ 同套代码在三种模式下结果一致
```

---

## 失败快速诊断

### 分层诊断策略
```
传输层失败(测试1) → 检查TransportBase.send()/receive()实现
注册失败(测试2) → 检查CommunicationManager.register_client()
远程调用失败(测试3) → 检查LearnerProxy/LearnerStub交互
流程失败(测试4) → 检查FederationCoordinator协调逻辑
兼容性失败(测试5) → 检查配置文件和组件工厂
```

这5个测试覆盖文档中的所有核心功能，确保系统按设计意图工作。每个测试专注一个关键能力，失败时能快速定位问题。