# è”é‚¦å­¦ä¹ æ¡†æ¶é‡æ„å®æ–½æŒ‡å—

## æ‰§è¡Œæ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å…·ä½“çš„é‡æ„å®æ–½æ­¥éª¤ï¼ŒæŒ‰ç…§**ä¸¥æ ¼çš„è‡ªä¸‹è€Œä¸Š**åŸåˆ™ï¼Œç¡®ä¿æ¯ä¸€å±‚éƒ½æ„å»ºåœ¨ç¨³å›ºçš„ä¸‹å±‚åŸºç¡€ä¹‹ä¸Šã€‚

## ğŸš€ å¼€å§‹æ‰§è¡Œï¼šç¬¬ä¸€é˜¶æ®µ - æ¸…ç†ä¸é‡ç»„

### 1.1 åˆ é™¤å†—ä½™æ–‡ä»¶

é¦–å…ˆæ¸…ç†æ‰€æœ‰é‡å¤ç‰ˆæœ¬å’Œä¸´æ—¶æ–‡ä»¶ï¼š

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•æ‰§è¡Œ
cd /Users/dongshou/projects/Moe-Fedcl

# åˆ é™¤oldç‰ˆæœ¬æ–‡ä»¶
rm fedcl/api/decorators_old.py
rm fedcl/transparent/execution_engine_old.py

# åˆ é™¤newç‰ˆæœ¬æ–‡ä»¶  
rm fedcl/api/decorators_new.py
rm fedcl/transparent/execution_engine_new.py
rm fedcl/methods/trainers/standard_federation_trainer_new.py

# åˆ é™¤backupæ–‡ä»¶
rm fedcl/__init__.py.backup

# åˆ é™¤å…¶ä»–ä¸´æ—¶æ–‡ä»¶
find fedcl/ -name "*.backup" -delete
find fedcl/ -name "*.tmp" -delete
```

### 1.2 åˆ›å»ºæ–°çš„åˆ†å±‚ç›®å½•ç»“æ„

```bash
# åˆ›å»ºæ–°çš„åˆ†å±‚ç›®å½•
mkdir -p fedcl/fl/trainers

mkdir -p fedcl/proxy

mkdir -p fedcl/strategy

mkdir -p fedcl/execution/local
mkdir -p fedcl/execution/pseudo  
mkdir -p fedcl/execution/distributed

mkdir -p fedcl/comm

# åˆ›å»ºå„å±‚çš„__init__.pyæ–‡ä»¶
touch fedcl/fl/__init__.py
touch fedcl/fl/trainers/__init__.py
touch fedcl/proxy/__init__.py
touch fedcl/strategy/__init__.py
touch fedcl/execution/__init__.py
touch fedcl/execution/local/__init__.py
touch fedcl/execution/pseudo/__init__.py
touch fedcl/execution/distributed/__init__.py
touch fedcl/comm/__init__.py
```

### 1.3 æ–‡ä»¶é‡æ–°åˆ†ç±»è®¡åˆ’

**ç°æœ‰æ–‡ä»¶åˆ†æä¸å½’å±**ï¼š

| ç°æœ‰æ–‡ä»¶ | ç›®æ ‡ä½ç½® | å¤„ç†æ–¹å¼ |
|---------|---------|---------|
| `transparent/abstract_federation_trainer.py` | `fl/trainers/` | ç§»åŠ¨+é‡æ„ |
| `transparent/learner_proxy.py` | `proxy/` | ç§»åŠ¨+å¢å¼º |
| `transparent/mode_detector.py` | `strategy/` | ç§»åŠ¨ |
| `transparent/strategy_selector.py` | `strategy/` | ç§»åŠ¨ |
| `implementations/federation/local_simulator.py` | `execution/local/` | ç§»åŠ¨+é‡æ„ |
| `implementations/federation/process_manager.py` | `execution/pseudo/` | ç§»åŠ¨+é‡æ„ |
| `implementations/federation/distributed_server.py` | `execution/distributed/` | ç§»åŠ¨+é‡æ„ |
| `implementations/federation/network_transport.py` | `transport/` | ç§»åŠ¨ |
| `engine/federation_engine.py` | å¾…è¯„ä¼° | å¯èƒ½åˆ é™¤ |

## ğŸ—ï¸ ç¬¬äºŒé˜¶æ®µ - åº•å±‚é‡æ„ (æœ€å…³é”®)

### 2.1 é€šä¿¡ä¼ è¾“å±‚æ„å»º

**ä¼˜å…ˆçº§ï¼šæœ€é«˜** - è¿™æ˜¯æ•´ä¸ªæ¶æ„çš„åŸºç¡€

#### 2.1.1 å†…å­˜ä¼ è¾“å™¨ (å•æœºæ¨¡æ‹Ÿ)
```python
# fedcl/comm/memory_transport.py
class MemoryTransport:
    """å†…å­˜ä¼ è¾“ - å•æœºå¤šçº¿ç¨‹/åç¨‹é€šä¿¡"""
    
    def __init__(self):
        self._memory_store = {}  # å…±äº«å†…å­˜å­˜å‚¨
        
    async def send(self, source: str, target: str, data: Any):
        """å‘é€æ•°æ®åˆ°ç›®æ ‡"""
        
    async def receive(self, target: str, source: str) -> Any:
        """ä»æºæ¥æ”¶æ•°æ®"""
        
    async def broadcast(self, source: str, targets: List[str], data: Any):
        """å¹¿æ’­æ•°æ®"""
```

#### 2.1.2 è¿›ç¨‹ä¼ è¾“å™¨ (ä¼ªè”é‚¦)
```python
# fedcl/comm/process_transport.py  
class ProcessTransport:
    """è¿›ç¨‹é—´ä¼ è¾“ - å¤šè¿›ç¨‹é€šä¿¡"""
    
    def __init__(self):
        self._queues = {}  # è¿›ç¨‹é—´é˜Ÿåˆ—
        
    async def send(self, source: str, target: str, data: Any):
        """é€šè¿‡é˜Ÿåˆ—å‘é€æ•°æ®"""
        
    async def receive(self, target: str, source: str) -> Any:
        """ä»é˜Ÿåˆ—æ¥æ”¶æ•°æ®"""
```

#### 2.1.3 ç½‘ç»œä¼ è¾“å™¨ (çœŸè”é‚¦)
```python
# fedcl/comm/network_transport.py
class NetworkTransport:
    """ç½‘ç»œä¼ è¾“ - çœŸå®åˆ†å¸ƒå¼é€šä¿¡"""
    
    def __init__(self, host: str, port: int):
        self._host = host
        self._port = port
        
    async def send(self, source: str, target: str, data: Any):
        """é€šè¿‡ç½‘ç»œå‘é€æ•°æ®"""
        
    async def receive(self, target: str, source: str) -> Any:
        """ä»ç½‘ç»œæ¥æ”¶æ•°æ®"""
```

### 2.2 æ‰§è¡Œå®ç°å±‚æ„å»º

#### 2.2.1 æœ¬åœ°æ‰§è¡Œå™¨
```python
# fedcl/execution/local/local_executor.py
class LocalExecutor:
    """æœ¬åœ°ä¸²è¡Œæ‰§è¡Œå™¨ - æœ€ç®€å•çš„å®ç°"""
    
    def __init__(self, transport: MemoryTransport):
        self._transport = transport
        
    async def execute_client_training(self, client_id: str, **kwargs):
        """æ‰§è¡Œå®¢æˆ·ç«¯è®­ç»ƒ - æœ¬åœ°ä¸²è¡Œç‰ˆæœ¬"""
        
    async def aggregate_results(self, results: List[Dict]) -> Dict:
        """èšåˆç»“æœ - æœ¬åœ°ç‰ˆæœ¬"""
```

#### 2.2.2 ä¼ªè”é‚¦æ‰§è¡Œå™¨
```python
# fedcl/execution/pseudo/pseudo_executor.py
class PseudoExecutor:
    """ä¼ªè”é‚¦å¤šè¿›ç¨‹æ‰§è¡Œå™¨"""
    
    def __init__(self, transport: ProcessTransport, num_processes: int):
        self._transport = transport
        self._processes = []
        
    async def execute_client_training(self, client_id: str, **kwargs):
        """æ‰§è¡Œå®¢æˆ·ç«¯è®­ç»ƒ - å¤šè¿›ç¨‹ç‰ˆæœ¬"""
```

#### 2.2.3 åˆ†å¸ƒå¼æ‰§è¡Œå™¨
```python
# fedcl/execution/distributed/distributed_executor.py  
class DistributedExecutor:
    """çœŸè”é‚¦åˆ†å¸ƒå¼æ‰§è¡Œå™¨"""
    
    def __init__(self, transport: NetworkTransport, client_endpoints: List[str]):
        self._transport = transport
        self._clients = client_endpoints
        
    async def execute_client_training(self, client_id: str, **kwargs):
        """æ‰§è¡Œå®¢æˆ·ç«¯è®­ç»ƒ - åˆ†å¸ƒå¼ç‰ˆæœ¬"""
```

### 2.3 ç­–ç•¥è°ƒåº¦å±‚æ„å»º

#### 2.3.1 æ¨¡å¼æ£€æµ‹å™¨
```python
# fedcl/strategy/mode_detector.py
class ModeDetector:
    """è‡ªåŠ¨æ£€æµ‹è¿è¡Œæ¨¡å¼"""
    
    @staticmethod
    def detect_mode(config: Dict[str, Any]) -> FederationMode:
        """æ ¹æ®é…ç½®å’Œç¯å¢ƒè‡ªåŠ¨æ£€æµ‹æ¨¡å¼"""
        
        # æ£€æŸ¥ç½‘ç»œé…ç½®
        if 'client_endpoints' in config:
            return FederationMode.TRUE_FEDERATION
            
        # æ£€æŸ¥è¿›ç¨‹é…ç½®  
        if config.get('use_multiprocessing', False):
            return FederationMode.PSEUDO_FEDERATION
            
        # é»˜è®¤æœ¬åœ°æ¨¡æ‹Ÿ
        return FederationMode.LOCAL_SIMULATION
```

#### 2.3.2 ç­–ç•¥é€‰æ‹©å™¨
```python
# fedcl/strategy/strategy_selector.py
class StrategySelector:
    """ç­–ç•¥é€‰æ‹©å™¨ - æ ¹æ®æ¨¡å¼é€‰æ‹©æ‰§è¡Œå™¨"""
    
    @staticmethod
    def select_executor(mode: FederationMode, config: Dict) -> AbstractExecutor:
        """é€‰æ‹©åˆé€‚çš„æ‰§è¡Œå™¨"""
        
        if mode == FederationMode.LOCAL_SIMULATION:
            transport = MemoryTransport()
            return LocalExecutor(transport)
            
        elif mode == FederationMode.PSEUDO_FEDERATION:
            transport = ProcessTransport()
            return PseudoExecutor(transport, config['num_processes'])
            
        else:
            transport = NetworkTransport(config['host'], config['port'])
            return DistributedExecutor(transport, config['client_endpoints'])
```

## ğŸ”— ç¬¬ä¸‰é˜¶æ®µ - ä¸­é—´å±‚é‡æ„

### 3.1 å­¦ä¹ å™¨ä»£ç† (è¿œç¨‹å‡½æ•°æ‰§è¡Œå™¨)

```python
# fedcl/proxy/learner_proxy.py
class LearnerProxy:
    """
    å­¦ä¹ å™¨ä»£ç† - è¿œç¨‹å‡½æ•°æ‰§è¡Œå™¨
    
    æ ¸å¿ƒä½œç”¨ï¼š
    1. é€æ˜åœ°æ‰§è¡Œè¿œç¨‹learneræ–¹æ³•
    2. è‡ªåŠ¨å¤„ç†å‚æ•°ä¼ é€’å’Œç»“æœè¿”å›
    3. æ”¯æŒæœ¬åœ°/å¤šè¿›ç¨‹/å¤šæœºä¸‰ç§æ‰§è¡Œæ¨¡å¼
    4. å¯¹ä¸Šå±‚trainerå®Œå…¨é€æ˜
    """
    
    def __init__(self, config: Dict[str, Any]):
        # è‡ªåŠ¨æ£€æµ‹æ¨¡å¼
        self._mode = ModeDetector.detect_mode(config)
        
        # é€‰æ‹©æ‰§è¡Œå™¨
        self._executor = StrategySelector.select_executor(self._mode, config)
        
        self._config = config
        
    async def train_epoch(self, client_id: str, **kwargs) -> Dict[str, Any]:
        """é€æ˜çš„è®­ç»ƒæ¥å£ - ç”¨æˆ·æ— éœ€çŸ¥é“åº•å±‚æ¨¡å¼"""
        return await self._executor.execute_client_training(client_id, **kwargs)
        
    async def get_model_weights(self, client_id: str) -> Dict[str, Any]:
        """è·å–æ¨¡å‹æƒé‡ - é€æ˜æ¥å£"""
        return await self._executor.get_client_weights(client_id)
        
    async def set_model_weights(self, client_id: str, weights: Dict[str, Any]):
        """è®¾ç½®æ¨¡å‹æƒé‡ - é€æ˜æ¥å£"""
        await self._executor.set_client_weights(client_id, weights)
        
    async def evaluate(self, client_id: str, **kwargs) -> Dict[str, Any]:
        """å®¢æˆ·ç«¯è¯„ä¼° - é€æ˜æ¥å£"""
        return await self._executor.evaluate_client(client_id, **kwargs)
```

### 3.2 é€šä¿¡ä»£ç†

```python
# fedcl/proxy/communication_proxy.py
class CommunicationProxy:
    """é€šä¿¡ä»£ç† - ç»Ÿä¸€é€šä¿¡æ¥å£"""
    
    def __init__(self, executor: AbstractExecutor):
        self._executor = executor
        
    async def broadcast(self, data: Any, target_clients: List[str]):
        """å¹¿æ’­æ•°æ®åˆ°å®¢æˆ·ç«¯ - è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ä¼ è¾“æ–¹å¼"""
        await self._executor.broadcast(data, target_clients)
        
    async def gather(self, source_clients: List[str]) -> List[Any]:
        """ä»å®¢æˆ·ç«¯æ”¶é›†æ•°æ®"""
        return await self._executor.gather(source_clients)
        
    async def send_to_client(self, client_id: str, data: Any):
        """å‘é€æ•°æ®åˆ°ç‰¹å®šå®¢æˆ·ç«¯"""
        await self._executor.send_to_client(client_id, data)
```

## ğŸ“‹ ç¬¬å››é˜¶æ®µ - ä¸Šå±‚é‡æ„

### 4.1 æŠ½è±¡è”é‚¦è®­ç»ƒå™¨

```python
# fedcl/fl/trainers/abstract_federation_trainer.py
class AbstractFederationTrainer(ABC):
    """æŠ½è±¡è”é‚¦è®­ç»ƒå™¨ - çº¯ä¸šåŠ¡é€»è¾‘åŸºç±»"""
    
    def __init__(self, config: Dict[str, Any]):
        self._config = config
        
        # åˆå§‹åŒ–ä»£ç†ç»„ä»¶ - è‡ªåŠ¨å¤„ç†æ‰€æœ‰åº•å±‚å¤æ‚æ€§
        self.learner_proxy = LearnerProxy(config)
        self.comm_proxy = CommunicationProxy(self.learner_proxy._executor)
        
        # ä¸šåŠ¡ç»„ä»¶
        self.aggregator = self._create_aggregator()
        self.client_selector = self._create_client_selector()
        
    @abstractmethod
    async def train(self) -> Dict[str, Any]:
        """ç”¨æˆ·å®ç°çš„è®­ç»ƒé€»è¾‘ - è¿™æ˜¯å”¯ä¸€éœ€è¦å­ç±»å®ç°çš„æ–¹æ³•"""
        pass
        
    # æä¾›é€šç”¨çš„ä¸šåŠ¡æ–¹æ³•
    def select_clients(self, round_num: int) -> List[str]:
        """å®¢æˆ·ç«¯é€‰æ‹©é€»è¾‘"""
        return self.client_selector.select(round_num)
        
    async def aggregate_weights(self, client_results: List[Dict]) -> Dict[str, Any]:
        """æƒé‡èšåˆé€»è¾‘"""
        return await self.aggregator.aggregate(client_results)
```

### 4.2 æ ‡å‡†è”é‚¦è®­ç»ƒå™¨å®ç°

```python
# fedcl/fl/trainers/standard_federation_trainer.py
class StandardFederationTrainer(AbstractFederationTrainer):
    """æ ‡å‡†FedAvgè®­ç»ƒå™¨ - ç¤ºä¾‹å®ç°"""
    
    async def train(self) -> Dict[str, Any]:
        """FedAvgè®­ç»ƒé€»è¾‘ - çº¯ä¸šåŠ¡é€»è¾‘ï¼Œæ— æ¨¡å¼æ„ŸçŸ¥"""
        
        results = {"rounds": [], "final_accuracy": 0.0}
        
        for round_num in range(self._config['num_rounds']):
            logger.info(f"å¼€å§‹è”é‚¦è½®æ¬¡ {round_num}")
            
            # 1. å®¢æˆ·ç«¯é€‰æ‹©
            selected_clients = self.select_clients(round_num)
            
            # 2. å¹¶è¡Œè®­ç»ƒ - é€æ˜çš„å¼‚æ­¥è°ƒç”¨ï¼Œåº•å±‚è‡ªåŠ¨å¤„ç†æ¨¡å¼å·®å¼‚
            training_tasks = [
                self.learner_proxy.train_epoch(client_id, round_num=round_num)
                for client_id in selected_clients
            ]
            
            client_results = await asyncio.gather(*training_tasks)
            
            # 3. æƒé‡èšåˆ
            aggregated_weights = await self.aggregate_weights(client_results)
            
            # 4. å…¨å±€æ¨¡å‹æ›´æ–°
            update_tasks = [
                self.learner_proxy.set_model_weights(client_id, aggregated_weights)
                for client_id in selected_clients
            ]
            
            await asyncio.gather(*update_tasks)
            
            # 5. è¯„ä¼°
            eval_tasks = [
                self.learner_proxy.evaluate(client_id)
                for client_id in selected_clients
            ]
            
            eval_results = await asyncio.gather(*eval_tasks)
            
            # è®°å½•ç»“æœ
            round_result = {
                "round": round_num,
                "participants": selected_clients,
                "accuracy": sum(r["accuracy"] for r in eval_results) / len(eval_results),
                "loss": sum(r["loss"] for r in eval_results) / len(eval_results)
            }
            
            results["rounds"].append(round_result)
            logger.info(f"è½®æ¬¡ {round_num} å®Œæˆï¼Œå¹³å‡å‡†ç¡®ç‡: {round_result['accuracy']:.4f}")
            
        results["final_accuracy"] = results["rounds"][-1]["accuracy"]
        return results
```

### 4.3 è£…é¥°å™¨APIé‡å»º

```python
# fedcl/api/decorators.py
def trainer(name: str, **trainer_config):
    """è®­ç»ƒå™¨è£…é¥°å™¨ - ç”¨æˆ·å‹å¥½çš„API"""
    
    def decorator(trainer_class):
        # æ³¨å†Œè®­ç»ƒå™¨
        TrainerRegistry.register(name, trainer_class, trainer_config)
        return trainer_class
        
    return decorator

def quick_start(config_path: str):
    """å¿«é€Ÿå¯åŠ¨è£…é¥°å™¨ - ä¸€é”®å¯åŠ¨è”é‚¦è®­ç»ƒ"""
    
    def decorator(trainer_class):
        async def run_federation():
            config = load_config(config_path)
            trainer = trainer_class(config)
            return await trainer.train()
            
        # ç«‹å³æ‰§è¡Œ
        return asyncio.run(run_federation())
        
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@trainer("fedavg")
class MyFedAvgTrainer(AbstractFederationTrainer):
    async def train(self):
        # ç”¨æˆ·åªéœ€è¦å†™ä¸šåŠ¡é€»è¾‘
        # æ‰€æœ‰è”é‚¦æ¨¡å¼å¤„ç†éƒ½æ˜¯é€æ˜çš„
        pass

@quick_start("config/my_experiment.yaml")
@trainer("fedavg")
class QuickExperiment(AbstractFederationTrainer):
    # ä¸€è¡Œä»£ç å¯åŠ¨è”é‚¦å­¦ä¹ å®éªŒ
    pass
```

## ğŸ§ª ç¬¬äº”é˜¶æ®µ - æµ‹è¯•ä¸éªŒè¯

### 5.1 å•å…ƒæµ‹è¯•ç­–ç•¥

æ¯å±‚ç‹¬ç«‹æµ‹è¯•ï¼Œä½¿ç”¨Mockéš”ç¦»ä¾èµ–ï¼š

```python
# tests/unit/transport/test_memory_transport.py
class TestMemoryTransport:
    async def test_send_receive(self):
        transport = MemoryTransport()
        await transport.send("client1", "server", {"data": "test"})
        result = await transport.receive("server", "client1")
        assert result["data"] == "test"

# tests/unit/proxy/test_learner_proxy.py  
class TestLearnerProxy:
    async def test_train_epoch_local_mode(self):
        config = {"mode": "local_simulation"}
        proxy = LearnerProxy(config)
        
        with patch.object(proxy._executor, 'execute_client_training') as mock:
            mock.return_value = {"loss": 0.5, "accuracy": 0.8}
            result = await proxy.train_epoch("client1")
            assert result["accuracy"] == 0.8
```

### 5.2 é›†æˆæµ‹è¯•ç­–ç•¥

æµ‹è¯•è·¨å±‚äº¤äº’å’Œæ¨¡å¼åˆ‡æ¢ï¼š

```python
# tests/integration/test_mode_switching.py
class TestModeSwitching:
    async def test_local_to_pseudo_switch(self):
        # æµ‹è¯•ä»æœ¬åœ°æ¨¡å¼åˆ‡æ¢åˆ°ä¼ªè”é‚¦æ¨¡å¼
        config_local = {"mode": "local_simulation"}
        config_pseudo = {"mode": "pseudo_federation", "num_processes": 3}
        
        # ä¸¤ç§æ¨¡å¼åº”è¯¥äº§ç”Ÿä¸€è‡´çš„ç»“æœ
        trainer1 = StandardFederationTrainer(config_local)
        trainer2 = StandardFederationTrainer(config_pseudo)
        
        result1 = await trainer1.train()
        result2 = await trainer2.train()
        
        # éªŒè¯ç»“æœä¸€è‡´æ€§
        assert abs(result1["final_accuracy"] - result2["final_accuracy"]) < 0.01
```

### 5.3 ç«¯åˆ°ç«¯æµ‹è¯•

éªŒè¯å®Œæ•´çš„ç”¨æˆ·ä½¿ç”¨æµç¨‹ï¼š

```python
# tests/e2e/test_user_experience.py
class TestUserExperience:
    async def test_decorator_api_usage(self):
        # éªŒè¯ç”¨æˆ·ä½¿ç”¨è£…é¥°å™¨APIçš„å®Œæ•´æµç¨‹
        
        @trainer("test_trainer")
        class TestTrainer(AbstractFederationTrainer):
            async def train(self):
                # æ¨¡æ‹Ÿç”¨æˆ·ä»£ç 
                for round_num in range(2):
                    clients = self.select_clients(round_num)
                    results = await asyncio.gather(*[
                        self.learner_proxy.train_epoch(c) for c in clients
                    ])
                    weights = await self.aggregate_weights(results)
                return {"final_accuracy": 0.85}
        
        config = {"num_rounds": 2, "num_clients": 3}
        trainer = TestTrainer(config)
        result = await trainer.train()
        
        assert "final_accuracy" in result
        assert result["final_accuracy"] > 0.8
```

## ğŸ“Š éªŒæ”¶æ ‡å‡†

### ä»£ç è´¨é‡æŒ‡æ ‡
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡ç‡ 100%  
- [ ] ä»£ç é‡å¤ç‡ < 5%
- [ ] åœˆå¤æ‚åº¦ < 10

### æ¶æ„æ¸…æ™°åº¦æŒ‡æ ‡
- [ ] æ¯ä¸ªæ–‡ä»¶èŒè´£å•ä¸€ (SRP)
- [ ] å±‚é—´ä¾èµ–å•å‘ (æ— å¾ªç¯ä¾èµ–)
- [ ] æ¥å£ä¸å®ç°åˆ†ç¦» (DIP)

### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
- [ ] ç”¨æˆ·ä»£ç è¡Œæ•°å‡å°‘ > 60%
- [ ] æ¨¡å¼åˆ‡æ¢æ— éœ€ä»£ç ä¿®æ”¹
- [ ] å¯åŠ¨æ—¶é—´ < 5ç§’

### æ€§èƒ½æŒ‡æ ‡
- [ ] å¹¶å‘æ‰§è¡Œæ•ˆç‡æå‡ > 50%
- [ ] å†…å­˜å ç”¨é™ä½ > 30%
- [ ] ç½‘ç»œé€šä¿¡å¼€é”€ä¼˜åŒ– > 40%

## âš ï¸ é£é™©æ§åˆ¶

### å¤‡ä»½ç­–ç•¥
åœ¨æ¯ä¸ªé˜¶æ®µå¼€å§‹å‰ï¼š
```bash
# åˆ›å»ºå¤‡ä»½åˆ†æ”¯
git checkout -b backup_before_phase_X
git add .
git commit -m "Backup before Phase X refactoring"

# ç»§ç»­åœ¨ä¸»åˆ†æ”¯å·¥ä½œ
git checkout main
```

### å›æ»šè®¡åˆ’
å¦‚æœæŸé˜¶æ®µå¤±è´¥ï¼š
```bash
# å›æ»šåˆ°å¤‡ä»½ç‚¹
git reset --hard backup_before_phase_X
# åˆ†æé—®é¢˜ï¼Œé‡æ–°åˆ¶å®šè®¡åˆ’
```

## ğŸ¯ æˆåŠŸæ ‡å¿—

é‡æ„æˆåŠŸçš„æœ€ç»ˆæ ‡å¿—æ˜¯ç”¨æˆ·å¯ä»¥è¿™æ ·å†™ä»£ç ï¼š

```python
# ç”¨æˆ·ä»£ç ç¤ºä¾‹ - ä¸é›†ä¸­å¼è®­ç»ƒå‡ ä¹å®Œå…¨ä¸€è‡´
@fedcl.trainer("my_fedavg") 
class MyFederationTrainer(AbstractFederationTrainer):
    async def train(self):
        for round_num in range(self.config.num_rounds):
            # é€‰æ‹©å®¢æˆ·ç«¯
            clients = self.select_clients(round_num)
            
            # è®­ç»ƒ - å®Œå…¨é€æ˜ï¼Œæ— éœ€å…³å¿ƒæ˜¯æœ¬åœ°ã€ä¼ªè”é‚¦è¿˜æ˜¯çœŸè”é‚¦
            results = await asyncio.gather(*[
                self.learner_proxy.train_epoch(client_id) 
                for client_id in clients
            ])
            
            # èšåˆ
            new_weights = await self.aggregate_weights(results)
            
            # æ›´æ–°
            await asyncio.gather(*[
                self.learner_proxy.set_model_weights(client_id, new_weights)
                for client_id in clients  
            ])
            
        return await self.get_final_results()

# é…ç½®æ–‡ä»¶é©±åŠ¨ï¼Œä¸€é”®åˆ‡æ¢æ¨¡å¼
# config.yaml:
# mode: "local_simulation"     # æœ¬åœ°å¼€å‘
# mode: "pseudo_federation"    # æœ¬åœ°æµ‹è¯•  
# mode: "true_federation"      # ç”Ÿäº§éƒ¨ç½²

# å¯åŠ¨
trainer = MyFederationTrainer("config.yaml")
results = await trainer.train()
```

**è¿™å°±æ˜¯æˆ‘ä»¬è¦è¾¾åˆ°çš„ç›®æ ‡ï¼šç”¨æˆ·å®Œå…¨æ„ŸçŸ¥ä¸åˆ°è”é‚¦å­¦ä¹ çš„å¤æ‚æ€§ï¼Œä»£ç å†™æ³•ä¸é›†ä¸­å¼è®­ç»ƒå®Œå…¨ä¸€è‡´ï¼**