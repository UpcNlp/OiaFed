# è”é‚¦å­¦ä¹ æ•°æ®é›†åŠ è½½æœºåˆ¶åˆ†æ

## æ¦‚è¿°

åœ¨è”é‚¦å­¦ä¹ ä¸­ï¼Œæ•°æ®é›†åŠ è½½æ˜¯ä¸€ä¸ªå…³é”®é—®é¢˜ï¼Œå› ä¸ºä¸åŒæ¨¡å¼ï¼ˆæœ¬åœ°æ¨¡æ‹Ÿã€ä¼ªè”é‚¦ã€çœŸè”é‚¦ï¼‰ä¸‹çš„æ•°æ®åˆ†å¸ƒå’Œè®¿é—®æ–¹å¼å®Œå…¨ä¸åŒã€‚æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æå½“å‰é¡¹ç›®ä¸­ä¸åŒæ¨¡å¼ä¸‹çš„æ•°æ®é›†åŠ è½½æœºåˆ¶ã€‚

## ä¸‰ç§æ¨¡å¼çš„æ•°æ®é›†åŠ è½½å¯¹æ¯”

### 1. æœ¬åœ°æ¨¡æ‹Ÿæ¨¡å¼ (Local Simulation)

#### ğŸ  **æ•°æ®åˆ†å¸ƒç‰¹ç‚¹**
- **æ•°æ®ä½ç½®**: æ‰€æœ‰æ•°æ®éƒ½åœ¨ä¸€å°æœºå™¨ä¸Š
- **æ•°æ®è®¿é—®**: ç›´æ¥å†…å­˜è®¿é—®ï¼Œé›¶ç½‘ç»œå¼€é”€
- **æ•°æ®åˆ†å‰²**: é€»è¾‘åˆ†å‰²ï¼Œç‰©ç†ä¸Šä»åœ¨ä¸€èµ·

#### ğŸ“Š **æ•°æ®é›†åŠ è½½æµç¨‹**
```
åŸå§‹æ•°æ®é›† (MNIST/CIFARç­‰)
    â†“
AutoDataManager.distribute_data()
    â†“
æ•°æ®åˆ†åŒºå™¨ (IIDPartitioner/NonIIDPartitioner)
    â†“
åˆ›å»ºæ•°æ®åˆ†åŒº (DataPartition)
    â†“
FederatedDataLoader ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯åˆ›å»ºå­æ•°æ®é›†
    â†“
å®¢æˆ·ç«¯é€šè¿‡ Subset(dataset, indices) è®¿é—®è‡ªå·±çš„æ•°æ®
```

#### ğŸ’» **å®ç°ç»†èŠ‚**
```python
# 1. æœåŠ¡ç«¯æ•°æ®åˆ†å‘
data_manager = AutoDataManager()
partitions = data_manager.distribute_data(
    dataset=mnist_dataset,
    num_clients=3,
    distribution_type=DataDistributionType.IID
)

# 2. ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯åˆ›å»ºæ•°æ®åŠ è½½å™¨
data_loaders = data_manager.create_federated_dataloaders(
    dataset=mnist_dataset,
    client_ids=["client_0", "client_1", "client_2"]
)

# 3. å®¢æˆ·ç«¯è®¿é—®æ•°æ®
client_dataset = Subset(mnist_dataset, partition.indices)
train_loader = DataLoader(client_dataset, batch_size=32)
```

#### âœ… **ä¼˜åŠ¿**
- å¼€å‘è°ƒè¯•ç®€å•
- æ— ç½‘ç»œå»¶è¿Ÿ
- æ•°æ®è®¿é—®å¿«é€Ÿ
- é€‚åˆç®—æ³•éªŒè¯

#### âŒ **åŠ£åŠ¿**
- ä¸æ˜¯çœŸå®çš„è”é‚¦å­¦ä¹ åœºæ™¯
- æ— æ³•æµ‹è¯•ç½‘ç»œé—®é¢˜
- æ•°æ®éšç§ä¿æŠ¤æœ‰é™

### 2. ä¼ªè”é‚¦æ¨¡å¼ (Pseudo-Federation)

#### ğŸ–¥ï¸ **æ•°æ®åˆ†å¸ƒç‰¹ç‚¹**
- **æ•°æ®ä½ç½®**: æ•°æ®ä»åœ¨åŒä¸€å°æœºå™¨ä¸Šï¼Œä½†å®¢æˆ·ç«¯è¿è¡Œåœ¨ä¸åŒè¿›ç¨‹ä¸­
- **æ•°æ®è®¿é—®**: è¿›ç¨‹é—´é€šä¿¡ï¼Œéœ€è¦åºåˆ—åŒ–
- **æ•°æ®åˆ†å‰²**: é€»è¾‘åˆ†å‰² + è¿›ç¨‹éš”ç¦»

#### ğŸ“Š **æ•°æ®é›†åŠ è½½æµç¨‹**
```
åŸå§‹æ•°æ®é›†
    â†“
AutoDataManager.distribute_data() (ä¸»è¿›ç¨‹)
    â†“
æ•°æ®åˆ†åŒºå™¨åˆ›å»ºåˆ†åŒº
    â†“
ä¸»è¿›ç¨‹å°†åˆ†åŒºä¿¡æ¯ä¼ é€’ç»™å­è¿›ç¨‹
    â†“
æ¯ä¸ªå­è¿›ç¨‹ç‹¬ç«‹åŠ è½½è‡ªå·±çš„æ•°æ®åˆ†åŒº
    â†“
å­è¿›ç¨‹é€šè¿‡ Subset(dataset, indices) è®¿é—®æ•°æ®
```

#### ğŸ’» **å®ç°ç»†èŠ‚**
```python
# 1. ä¸»è¿›ç¨‹æ•°æ®åˆ†å‘
def _run_learner_in_process(client_id, config, method, **kwargs):
    # åœ¨å­è¿›ç¨‹ä¸­å¯¼å…¥å¹¶åˆ›å»ºlearner
    from fedcl.execution.base_learner import StandardLearner
    
    # å­è¿›ç¨‹ç‹¬ç«‹åŠ è½½æ•°æ®é›†
    dataset = load_dataset(config["dataset_name"])
    
    # æ ¹æ®client_idè·å–å¯¹åº”çš„æ•°æ®åˆ†åŒº
    partition = get_client_partition(client_id, dataset)
    client_dataset = Subset(dataset, partition.indices)
    
    # åˆ›å»ºlearnerå¹¶è®­ç»ƒ
    learner = StandardLearner(client_id, config)
    result = learner.train_epoch(train_loader=DataLoader(client_dataset))
    return result

# 2. ä¸»è¿›ç¨‹å¯åŠ¨å­è¿›ç¨‹
executor = ProcessPoolExecutor(max_workers=4)
future = executor.submit(_run_learner_in_process, client_id, config, "train_epoch")
result = future.result()
```

#### âœ… **ä¼˜åŠ¿**
- çœŸå®çš„è¿›ç¨‹éš”ç¦»
- å¯ä»¥æµ‹è¯•å¹¶å‘é—®é¢˜
- æ¥è¿‘çœŸå®è”é‚¦å­¦ä¹ åœºæ™¯
- æ•°æ®è®¿é—®ç›¸å¯¹å¿«é€Ÿ

#### âŒ **åŠ£åŠ¿**
- ä»éœ€è¦åºåˆ—åŒ–å¼€é”€
- æ•°æ®ä»åœ¨åŒä¸€å°æœºå™¨ä¸Š
- æ— æ³•æµ‹è¯•ç½‘ç»œé—®é¢˜

### 3. çœŸè”é‚¦æ¨¡å¼ (True Federation)

#### ğŸŒ **æ•°æ®åˆ†å¸ƒç‰¹ç‚¹**
- **æ•°æ®ä½ç½®**: æ•°æ®åˆ†å¸ƒåœ¨ä¸åŒæœºå™¨ä¸Š
- **æ•°æ®è®¿é—®**: ç½‘ç»œé€šä¿¡ï¼Œéœ€è¦ç½‘ç»œä¼ è¾“
- **æ•°æ®åˆ†å‰²**: ç‰©ç†åˆ†å‰²ï¼Œæ¯å°æœºå™¨æœ‰è‡ªå·±çš„æ•°æ®

#### ğŸ“Š **æ•°æ®é›†åŠ è½½æµç¨‹**
```
æœåŠ¡ç«¯ (æ— æ•°æ®)
    â†“
å®¢æˆ·ç«¯1 (æœºå™¨A) - åŠ è½½æœ¬åœ°æ•°æ®é›†A
å®¢æˆ·ç«¯2 (æœºå™¨B) - åŠ è½½æœ¬åœ°æ•°æ®é›†B  
å®¢æˆ·ç«¯3 (æœºå™¨C) - åŠ è½½æœ¬åœ°æ•°æ®é›†C
    â†“
æ¯ä¸ªå®¢æˆ·ç«¯ç‹¬ç«‹ç®¡ç†è‡ªå·±çš„æ•°æ®
    â†“
é€šè¿‡ç½‘ç»œé€šä¿¡è¿›è¡Œæ¨¡å‹èšåˆ
```

#### ğŸ’» **å®ç°ç»†èŠ‚**
```python
# 1. æœåŠ¡ç«¯ (æ— æ•°æ®ï¼Œåªè´Ÿè´£åè°ƒ)
class DistributedExecutor:
    async def execute_client_training(self, client_id: str, **kwargs):
        # é€šè¿‡ç½‘ç»œè°ƒç”¨è¿œç¨‹å®¢æˆ·ç«¯çš„è®­ç»ƒæ–¹æ³•
        result = await self._call_remote_method(
            client_id, "train_epoch", **kwargs
        )
        return result

# 2. å®¢æˆ·ç«¯ (ç‹¬ç«‹æœºå™¨ï¼Œæœ‰è‡ªå·±çš„æ•°æ®)
class ClientNode:
    def __init__(self, client_id, data_path):
        # å®¢æˆ·ç«¯åŠ è½½è‡ªå·±çš„æœ¬åœ°æ•°æ®
        self.dataset = load_local_dataset(data_path)
        self.train_loader = DataLoader(self.dataset, batch_size=32)
    
    async def train_epoch(self, **kwargs):
        # ä½¿ç”¨æœ¬åœ°æ•°æ®è¿›è¡Œè®­ç»ƒ
        learner = StandardLearner(self.client_id, self.config)
        result = learner.train_epoch(train_loader=self.train_loader)
        return result
```

#### âœ… **ä¼˜åŠ¿**
- çœŸå®çš„åˆ†å¸ƒå¼åœºæ™¯
- çœŸæ­£çš„æ•°æ®éšç§ä¿æŠ¤
- å¯ä»¥æµ‹è¯•ç½‘ç»œé—®é¢˜
- ç”Ÿäº§ç¯å¢ƒå°±ç»ª

#### âŒ **åŠ£åŠ¿**
- éƒ¨ç½²å¤æ‚
- ç½‘ç»œå»¶è¿Ÿå’Œå¸¦å®½é™åˆ¶
- è°ƒè¯•å›°éš¾
- éœ€è¦ç½‘ç»œåŸºç¡€è®¾æ–½

## æ•°æ®åŠ è½½å™¨çš„ç»Ÿä¸€æ¥å£

### ğŸ”§ **FederatedDataLoader è®¾è®¡**

æ— è®ºå“ªç§æ¨¡å¼ï¼Œéƒ½ä½¿ç”¨ç»Ÿä¸€çš„ `FederatedDataLoader` æ¥å£ï¼š

```python
class FederatedDataLoader:
    def __init__(self, dataset: Dataset, partition: DataPartition, config: DataConfig):
        # åˆ›å»ºå®¢æˆ·ç«¯å­æ•°æ®é›†
        self.client_dataset = Subset(dataset, partition.indices)
        
        # åˆ†å‰²è®­ç»ƒå’ŒéªŒè¯æ•°æ®
        self.train_loader, self.val_loader = self._create_data_loaders()
    
    def _create_data_loaders(self):
        # ç»Ÿä¸€çš„DataLoaderåˆ›å»ºé€»è¾‘
        train_loader = DataLoader(
            self.client_dataset,
            batch_size=self.config.batch_size,
            shuffle=self.config.shuffle
        )
        return train_loader, val_loader
```

### ğŸ“‹ **æ•°æ®åˆ†åŒºä¿¡æ¯**

æ¯ä¸ªå®¢æˆ·ç«¯çš„æ•°æ®åˆ†åŒºåŒ…å«ï¼š

```python
@dataclass
class DataPartition:
    client_id: str
    indices: List[int]  # æ•°æ®ç´¢å¼•
    labels: List[int]   # æ ‡ç­¾ä¿¡æ¯
    size: int          # æ•°æ®é‡
    distribution_info: Dict[str, Any]  # åˆ†å¸ƒç»Ÿè®¡ä¿¡æ¯
```

## æ•°æ®åˆ†å¸ƒç­–ç•¥

### ğŸ² **IID åˆ†å¸ƒ (ç‹¬ç«‹åŒåˆ†å¸ƒ)**
```python
class IIDPartitioner(BaseDataPartitioner):
    def partition_data(self, dataset: Dataset) -> List[DataPartition]:
        # éšæœºæ‰“ä¹±æ•°æ®
        indices = np.random.permutation(len(dataset))
        
        # å¹³å‡åˆ†é…ç»™å„å®¢æˆ·ç«¯
        partition_size = len(dataset) // num_clients
        for i in range(num_clients):
            start_idx = i * partition_size
            end_idx = (i + 1) * partition_size
            client_indices = indices[start_idx:end_idx]
            # åˆ›å»ºåˆ†åŒº...
```

### ğŸ¯ **Non-IID åˆ†å¸ƒ (éç‹¬ç«‹åŒåˆ†å¸ƒ)**
```python
class NonIIDLabelPartitioner(BaseDataPartitioner):
    def partition_data(self, dataset: Dataset) -> List[DataPartition]:
        # ä½¿ç”¨Dirichletåˆ†å¸ƒä¸ºæ¯ä¸ªå®¢æˆ·ç«¯åˆ†é…ç±»åˆ«æ¯”ä¾‹
        proportions = np.random.dirichlet([alpha] * num_classes)
        
        # æ ¹æ®æ¯”ä¾‹ä»æ¯ä¸ªç±»åˆ«é‡‡æ ·
        for class_id, proportion in enumerate(proportions):
            num_samples = int(proportion * min_samples_per_client)
            # é‡‡æ ·å¹¶åˆ†é…...
```

## æ¨¡å¼åˆ‡æ¢çš„é€æ˜æ€§

### ğŸ”„ **è‡ªåŠ¨æ¨¡å¼æ£€æµ‹**

é¡¹ç›®é€šè¿‡ `ModeDetector` è‡ªåŠ¨æ£€æµ‹è¿è¡Œç¯å¢ƒï¼š

```python
class ModeDetector:
    def detect_mode(self) -> ExecutionMode:
        # æ£€æµ‹ç½‘ç»œç¯å¢ƒ
        if self._has_network_clients():
            return ExecutionMode.TRUE_FEDERATION
        elif self._has_multiple_processes():
            return ExecutionMode.PSEUDO_FEDERATION
        else:
            return ExecutionMode.LOCAL_SIMULATION
```

### ğŸ­ **é€æ˜æ•°æ®è®¿é—®**

é€šè¿‡ `LearnerProxy` å®ç°é€æ˜çš„æ•°æ®è®¿é—®ï¼š

```python
class LearnerProxy:
    def train_task(self, task_data):
        # æ ¹æ®å½“å‰æ¨¡å¼è‡ªåŠ¨é€‰æ‹©æ•°æ®è®¿é—®æ–¹å¼
        if self.mode == ExecutionMode.LOCAL_SIMULATION:
            return self._local_training(task_data)
        elif self.mode == ExecutionMode.PSEUDO_FEDERATION:
            return self._process_training(task_data)
        else:  # TRUE_FEDERATION
            return self._network_training(task_data)
```

## æ€»ç»“

### ğŸ“Š **æ¨¡å¼å¯¹æ¯”è¡¨**

| ç‰¹æ€§ | æœ¬åœ°æ¨¡æ‹Ÿ | ä¼ªè”é‚¦ | çœŸè”é‚¦ |
|------|----------|--------|--------|
| **æ•°æ®ä½ç½®** | å•æœºå†…å­˜ | å•æœºå¤šè¿›ç¨‹ | å¤šæœºåˆ†å¸ƒ |
| **æ•°æ®è®¿é—®** | ç›´æ¥è®¿é—® | è¿›ç¨‹é—´é€šä¿¡ | ç½‘ç»œé€šä¿¡ |
| **æ•°æ®åˆ†å‰²** | é€»è¾‘åˆ†å‰² | é€»è¾‘+è¿›ç¨‹éš”ç¦» | ç‰©ç†åˆ†å‰² |
| **å¼€å‘éš¾åº¦** | ç®€å• | ä¸­ç­‰ | å¤æ‚ |
| **çœŸå®ç¨‹åº¦** | ä½ | ä¸­ç­‰ | é«˜ |
| **æ€§èƒ½** | æœ€å¿« | å¿« | å—ç½‘ç»œå½±å“ |
| **éšç§ä¿æŠ¤** | æœ‰é™ | ä¸­ç­‰ | æœ€å¼º |

### ğŸ¯ **æœ€ä½³å®è·µå»ºè®®**

1. **å¼€å‘é˜¶æ®µ**: ä½¿ç”¨æœ¬åœ°æ¨¡æ‹Ÿæ¨¡å¼å¿«é€ŸéªŒè¯ç®—æ³•
2. **æµ‹è¯•é˜¶æ®µ**: ä½¿ç”¨ä¼ªè”é‚¦æ¨¡å¼æµ‹è¯•å¹¶å‘å’Œè¿›ç¨‹éš”ç¦»
3. **ç”Ÿäº§é˜¶æ®µ**: ä½¿ç”¨çœŸè”é‚¦æ¨¡å¼éƒ¨ç½²åˆ°å®é™…ç¯å¢ƒ

### ğŸ”§ **é…ç½®ç¤ºä¾‹**

```yaml
# æœ¬åœ°æ¨¡æ‹Ÿé…ç½®
federation:
  mode: "local_simulation"
  data_distribution: "iid"

# ä¼ªè”é‚¦é…ç½®  
federation:
  mode: "pseudo_federation"
  max_processes: 4
  data_distribution: "non_iid_label"

# çœŸè”é‚¦é…ç½®
federation:
  mode: "true_federation"
  client_endpoints:
    client_1: "http://192.168.1.10:8080"
    client_2: "http://192.168.1.11:8080"
    client_3: "http://192.168.1.12:8080"
```

è¿™ç§è®¾è®¡ç¡®ä¿äº†ç”¨æˆ·å¯ä»¥åœ¨ä¸åŒæ¨¡å¼ä¸‹ä½¿ç”¨ç›¸åŒçš„ä»£ç ï¼Œè€Œåº•å±‚çš„æ•°æ®åŠ è½½æœºåˆ¶ä¼šæ ¹æ®ç¯å¢ƒè‡ªåŠ¨é€‚é…ã€‚
