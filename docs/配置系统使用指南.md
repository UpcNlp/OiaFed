# MOE-FedCL 配置系统使用指南

## 概述

MOE-FedCL 提供了类型安全的配置系统，支持 YAML 文件配置和代码配置两种方式。

## 配置文件位置

```
MOE-FedCL/
├── fedcl/
│   └── config.py              # 配置类定义
├── configs/
│   ├── server_demo.yaml       # 服务端配置示例
│   └── client_demo.yaml       # 客户端配置示例
└── examples/
    └── config_usage_demo.py   # 使用示例
```

## 快速开始

### 方式1: 使用 YAML 配置文件

**1. 创建服务端**

```python
from fedcl.config import load_server_config
from fedcl.federation.server import FederationServer

# 加载配置
config = load_server_config("configs/server_demo.yaml")

# 创建服务端
server = FederationServer(config.to_dict())
```

**2. 创建客户端**

```python
from fedcl.config import load_client_config
from fedcl.federation.client import FederationClient

# 加载配置
config = load_client_config("configs/client_demo_1.yaml")

# 创建客户端
client = FederationClient(config.to_dict())
```

### 方式2: 使用代码配置

**1. 使用默认配置**

```python
from fedcl.config import create_default_server_config, create_default_client_config

# 创建默认服务端配置
server_config = create_default_server_config(mode="process", port=8000)

# 创建默认客户端配置
client_config = create_default_client_config(
    mode="process",
    server_host="127.0.0.1",
    server_port=8000
)
```

**2. 自定义配置**

```python
from fedcl.config import ServerConfig, ClientConfig, TransportLayerConfig

# 自定义服务端配置
server_config = ServerConfig(
    mode="process",
    server_port=9000,
    transport=TransportLayerConfig(
        timeout=60.0,
        retry_attempts=5
    )
)

# 自定义客户端配置
client_config = ClientConfig(
    mode="process",
    server_port=9000,
    client_port=0  # 自动分配
)
```

## 配置层次结构

### 服务端配置 (`ServerConfig`)

```python
ServerConfig(
    # 基本配置
    mode: str = "process"              # 通信模式
    server_id: Optional[str] = None    # 服务端ID（自动生成）
    server_host: str = "127.0.0.1"     # 监听地址
    server_port: int = 8000            # 监听端口

    # 传输层配置
    transport: TransportLayerConfig

    # 通信层配置
    communication: CommunicationLayerConfig

    # 联邦学习层配置
    federation: FederationLayerConfig
)
```

### 客户端配置 (`ClientConfig`)

```python
ClientConfig(
    # 基本配置
    mode: str = "process"              # 通信模式
    client_id: Optional[str] = None    # 客户端ID（自动生成）

    # 服务端连接信息
    server_host: str = "127.0.0.1"     # 服务端地址
    server_port: int = 8000            # 服务端端口

    # 客户端监听配置
    client_host: str = "127.0.0.1"     # 客户端监听地址
    client_port: int = 0               # 客户端端口（0=自动分配）

    # 传输层配置
    transport: TransportLayerConfig

    # 通信层配置
    communication: CommunicationLayerConfig

    # Stub层配置
    stub: StubLayerConfig
)
```

## 配置详解

### 传输层配置 (`TransportLayerConfig`)

```yaml
transport:
  timeout: 30.0              # 请求超时时间（秒）
  retry_attempts: 3          # 重试次数
  host: "127.0.0.1"          # 监听地址
  port: 8000                 # 监听端口
  websocket_port: 9501       # WebSocket端口
  ssl_enabled: false         # 是否启用SSL
  connection_timeout: 30.0   # 连接超时
```

### 通信层配置 (`CommunicationLayerConfig`)

```yaml
communication:
  heartbeat_interval: 30.0   # 心跳间隔（秒）
  heartbeat_timeout: 90.0    # 心跳超时（秒）
  registration_timeout: 60.0 # 注册超时（秒）
  max_clients: 100           # 最大客户端数
  rpc_timeout: 120.0         # RPC超时（秒）
```

### 联邦学习层配置 (`FederationLayerConfig`)

```yaml
federation:
  coordinator_id: "fed_coordinator"
  max_rounds: 100            # 最大训练轮数
  min_clients: 2             # 最小客户端数
  client_selection: "all"    # 客户端选择策略
  training_config:           # 训练配置
    aggregation_method: "fedavg"
```

### Stub层配置 (`StubLayerConfig`) - 客户端专用

```yaml
stub:
  auto_register: true                # 自动注册
  registration_retry_attempts: 3     # 注册重试次数
  registration_retry_delay: 5.0      # 重试间隔（秒）
  request_timeout: 120.0             # 请求超时
  max_concurrent_requests: 5         # 最大并发请求
```

## 三种通信模式配置

### Memory 模式（单进程内存）

**特点**: 所有组件在同一进程，适合快速开发和调试

```yaml
mode: memory
```

```python
config = ServerConfig(mode="memory")
```

### Process 模式（多进程本地）

**特点**: 服务端和客户端在不同进程，使用HTTP通信，适合本地测试

**服务端配置**:
```yaml
mode: process
server_host: "127.0.0.1"  # Process模式固定为127.0.0.1
server_port: 8000
```

**客户端配置**:
```yaml
mode: process
server_host: "127.0.0.1"
server_port: 8000
client_port: 0  # 自动分配端口
```

### Network 模式（分布式网络）

**特点**: 服务端和客户端可在不同机器，适合真实部署

**服务端配置**:
```yaml
mode: network
server_host: "0.0.0.0"  # 监听所有网络接口
server_port: 8000
```

**客户端配置**:
```yaml
mode: network
server_host: "192.168.1.100"  # 服务端实际IP
server_port: 8000
client_host: "192.168.1.101"  # 客户端实际IP
client_port: 8001
```

## 完整使用示例

### 服务端启动

```python
import asyncio
from fedcl.config import load_server_config
from fedcl.federation.server import FederationServer
from fedcl.trainer.base_trainer import BaseTrainer

class MyTrainer(BaseTrainer):
    async def aggregate_models(self, client_models):
        # 聚合逻辑
        return aggregated_model

    async def train_round(self, round_num: int):
        # 训练逻辑
        return results

async def main():
    # 1. 加载配置
    config = load_server_config("configs/server_demo.yaml")

    # 2. 创建服务端
    server = FederationServer(config.to_dict())

    # 3. 初始化训练器
    trainer = await server.initialize_with_trainer(
        trainer_class=MyTrainer,
        global_model={},
        trainer_config={}
    )

    # 4. 启动服务端
    await server.start_server()

    # 5. 运行训练
    # ...

    # 6. 停止服务端
    await server.stop_server()

if __name__ == "__main__":
    asyncio.run(main())
```

### 客户端启动

```python
import asyncio
from fedcl.config import load_client_config
from fedcl.federation.client import FederationClient
from fedcl.learner.base_learner import BaseLearner

class MyLearner(BaseLearner):
    async def train(self, global_model, **kwargs):
        # 本地训练逻辑
        return {"loss": 0.5}

    async def evaluate(self, model, **kwargs):
        # 本地评估逻辑
        return {"accuracy": 0.9}

async def main():
    # 1. 加载配置
    config = load_client_config("configs/client_demo_1.yaml")

    # 2. 创建客户端
    client = FederationClient(config.to_dict())

    # 3. 初始化学习器
    learner = await client.initialize_with_learner(
        learner_class=MyLearner,
        learner_config={}
    )

    # 4. 启动客户端（自动注册）
    await client.start_client()

    # 5. 等待训练任务
    # ...

    # 6. 停止客户端
    await client.stop_client()

if __name__ == "__main__":
    asyncio.run(main())
```

### 多客户端启动

```python
async def start_multiple_clients(num_clients: int):
    """启动多个客户端"""
    clients = []

    # 加载基础配置
    base_config = load_client_config("configs/client_demo_1.yaml")

    # 创建多个客户端
    for i in range(num_clients):
        # 为每个客户端创建独立配置
        config = ClientConfig.from_dict(base_config.to_dict())
        config.client_id = f"client_{i+1}"

        # 创建客户端实例
        client = FederationClient(
            config.to_dict(),
            client_id=config.client_id
        )

        # 初始化学习器
        await client.initialize_with_learner(
            learner_class=MyLearner,
            learner_config={}
        )

        # 启动客户端
        await client.start_client()

        clients.append(client)

    return clients
```

## 配置最佳实践

### 1. 开发阶段

使用 **Memory 模式**进行快速开发和调试：

```yaml
mode: memory
```

### 2. 本地测试阶段

使用 **Process 模式**测试多客户端场景：

```yaml
mode: process
server_port: 8000
client_port: 0  # 自动分配
```

### 3. 生产部署阶段

使用 **Network 模式**进行分布式部署：

```yaml
mode: network
server_host: "0.0.0.0"
server_port: 8000
ssl_enabled: true  # 启用SSL
```

### 4. 端口配置建议

- **服务端**: 使用固定端口（如 8000）
- **客户端**: 使用自动分配（port: 0），避免端口冲突
- **客户端注册时会告知服务端实际端口**

### 5. 超时配置建议

根据网络环境和任务复杂度调整：

```yaml
transport:
  timeout: 60.0  # 慢网络环境增加超时

communication:
  rpc_timeout: 300.0  # 复杂训练任务增加RPC超时
```

## 更多示例

完整的使用示例请参考：
- `examples/config_usage_demo.py` - 配置使用示例
- `examples/mnist_process_demo.py` - Process模式完整示例
- `configs/server_demo.yaml` - 服务端配置模板
- `configs/client_demo.yaml` - 客户端配置模板

## 常见问题

### Q: 客户端端口为什么要设置为0？

A: 设置为0表示由操作系统自动分配可用端口，避免多客户端同时启动时的端口冲突。客户端会在注册时将实际端口告知服务端。

### Q: Process模式和Network模式有什么区别？

A:
- **Process模式**: 强制使用 127.0.0.1（本地回环），适合单机多进程测试
- **Network模式**: 可以配置任意IP地址，适合跨机器分布式部署
- 两者都使用HTTP通信，底层实现相同

### Q: 如何修改配置？

A: 三种方式：
1. 直接修改 YAML 文件
2. 代码中创建配置对象并修改属性
3. 使用 `from_dict()` 从字典创建配置

### Q: 配置类和原有字典配置兼容吗？

A: 完全兼容。配置类提供了 `to_dict()` 方法转换为原有的字典格式，现有代码无需修改。
