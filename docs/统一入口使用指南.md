# MOE-FedCL 统一入口使用指南

## 概述

`FederatedLearning` 类是 MOE-FedCL 的统一入口，整合了 `FederationServer`、`FederationClient` 和 `FederationCoordinator`，让您可以用最简单的方式启动完整的联邦学习系统。

## 核心优势

1. **一站式启动**: 一个类管理服务端、客户端和协调器
2. **配置驱动**: 支持 YAML 配置文件或代码配置
3. **自动管理**: 自动处理组件初始化、启动和清理
4. **异步上下文**: 支持 `async with` 自动资源管理
5. **类型安全**: 完整的类型提示和错误处理

## 快速开始

### 最简单的方式：一行代码

```python
import asyncio
from fedcl import run_federated_learning, BaseTrainer, BaseLearner

async def main():
    result = await run_federated_learning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        server_config_path="configs/server_demo.yaml",
        client_config_path="configs/client_demo_1.yaml",
        num_clients=5,
        max_rounds=10
    )
    print(f"训练完成！准确率: {result.final_accuracy:.4f}")

asyncio.run(main())
```

### 推荐方式：使用上下文管理器

```python
from fedcl import FederatedLearning, FederationConfig

async with FederatedLearning(
    trainer_class=MyTrainer,
    learner_class=MyLearner,
    global_model={"weights": [0.1, 0.2, 0.3]},
    server_config_path="configs/server_demo.yaml",
    client_config_path="configs/client_demo_1.yaml",
    num_clients=5,
    federation_config=FederationConfig(max_rounds=10, min_clients=3)
) as fl:
    result = await fl.run()
    print(f"训练完成！准确率: {result.final_accuracy:.4f}")
```

## FederatedLearning 类详解

### 初始化参数

```python
FederatedLearning(
    # ===== 必需参数 =====
    trainer_class: Type[BaseTrainer],     # 训练器类
    learner_class: Type[BaseLearner],     # 学习器类
    global_model: ModelData,              # 初始全局模型

    # ===== 服务端配置（二选一）=====
    server_config_path: Optional[str] = None,      # 配置文件路径
    server_config: Optional[ServerConfig] = None,  # 配置对象
    server_id: Optional[str] = None,               # 服务端节点ID（可选）

    # ===== 客户端配置（二选一）=====
    client_config_path: Optional[str] = None,      # 配置文件路径
    client_config: Optional[ClientConfig] = None,  # 配置对象
    num_clients: int = 2,                          # 客户端数量
    client_ids: Optional[List[str]] = None,        # 客户端节点ID列表（可选）

    # ===== 额外配置 =====
    trainer_config: Optional[Dict[str, Any]] = None,         # 训练器配置
    learner_config: Optional[Dict[str, Any]] = None,         # 学习器配置
    federation_config: Optional[FederationConfig] = None,    # 联邦配置

    # ===== 其他选项 =====
    auto_setup_logging: bool = True       # 自动设置日志
)
```

**节点ID参数说明**：
- `server_id`: 服务端节点ID（可选）
  - 如果不指定，将使用配置中的ID或自动生成
  - 示例：`"my_server"`, `"central_coordinator"`, `"edge_hub"`

- `client_ids`: 客户端节点ID列表（可选）
  - 如果不指定，将自动生成 `client_1`, `client_2`, ...
  - 必须与 `num_clients` 的数量一致
  - 示例：`["alice", "bob", "charlie"]`, `["hospital_A", "hospital_B"]`

### 主要方法

#### `initialize()`
初始化所有组件（服务端、客户端、协调器）

```python
await fl.initialize()
```

执行流程：
1. 初始化并启动服务端
2. 等待服务端完全启动
3. 并发初始化并启动所有客户端
4. 等待客户端注册完成
5. 创建联邦学习协调器

#### `run(max_rounds: Optional[int] = None)`
运行联邦学习训练

```python
result = await fl.run(max_rounds=10)
```

返回 `FederationResult` 对象，包含：
- `completed_rounds`: 完成的轮数
- `final_accuracy`: 最终准确率
- `final_loss`: 最终损失
- `total_time`: 总训练时间
- `round_results`: 每轮的详细结果

#### `cleanup()`
清理所有资源

```python
await fl.cleanup()
```

执行流程：
1. 停止所有客户端
2. 停止服务端
3. 清理内部状态

## 使用示例

### 示例1: 使用配置文件

**准备配置文件**

`configs/server_demo.yaml`:
```yaml
mode: process
server_host: "127.0.0.1"
server_port: 8000

federation:
  max_rounds: 100
  min_clients: 3
```

`configs/client_demo.yaml`:
```yaml
mode: process
server_host: "127.0.0.1"
server_port: 8000
client_port: 0  # 自动分配
```

**代码**:
```python
import asyncio
from fedcl import FederatedLearning, BaseTrainer, BaseLearner

class MyTrainer(BaseTrainer):
    async def train_round(self, round_num: int, client_ids: List[str]) -> RoundResult:
        # 实现训练逻辑
        pass

    async def aggregate_models(self, client_results: Dict[str, Any]) -> ModelData:
        # 实现聚合逻辑
        pass

class MyLearner(BaseLearner):
    async def train(self, training_params: Dict[str, Any]) -> TrainingResult:
        # 实现本地训练
        pass

    async def evaluate(self, evaluation_params: Dict[str, Any]) -> EvaluationResult:
        # 实现本地评估
        pass

async def main():
    async with FederatedLearning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        server_config_path="configs/server_demo.yaml",
        client_config_path="configs/client_demo_1.yaml",
        num_clients=5
    ) as fl:
        result = await fl.run(max_rounds=10)

        print("="*60)
        print(f"训练完成！")
        print(f"  完成轮数: {result.completed_rounds}")
        print(f"  最终准确率: {result.final_accuracy:.4f}")
        print(f"  最终损失: {result.final_loss:.4f}")
        print(f"  总耗时: {result.total_time:.2f}秒")
        print("="*60)

if __name__ == "__main__":
    asyncio.run(main())
```

### 示例2: 使用配置对象

```python
from fedcl import FederatedLearning, ServerConfig, ClientConfig, FederationConfig

async def main():
    # 创建服务端配置
    server_config = ServerConfig(
        mode="process",
        server_host="127.0.0.1",
        server_port=8000
    )

    # 创建客户端配置
    client_config = ClientConfig(
        mode="process",
        server_host="127.0.0.1",
        server_port=8000,
        client_port=0
    )

    # 创建联邦配置
    federation_config = FederationConfig(
        max_rounds=10,
        min_clients=3,
        client_selection="all"
    )

    async with FederatedLearning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        server_config=server_config,
        client_config=client_config,
        num_clients=5,
        federation_config=federation_config
    ) as fl:
        result = await fl.run()

if __name__ == "__main__":
    asyncio.run(main())
```

### 示例3: 使用默认配置

```python
from fedcl import FederatedLearning

async def main():
    # 不提供配置，使用默认值
    async with FederatedLearning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        num_clients=3
    ) as fl:
        result = await fl.run(max_rounds=10)

if __name__ == "__main__":
    asyncio.run(main())
```

### 示例4: 手动管理生命周期

```python
from fedcl import FederatedLearning

async def main():
    # 创建实例
    fl = FederatedLearning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        server_config_path="configs/server_demo.yaml",
        client_config_path="configs/client_demo_1.yaml",
        num_clients=5
    )

    try:
        # 手动初始化
        await fl.initialize()

        # 运行训练
        result = await fl.run(max_rounds=10)

        print(f"训练完成！准确率: {result.final_accuracy:.4f}")

    finally:
        # 手动清理
        await fl.cleanup()

if __name__ == "__main__":
    asyncio.run(main())
```

### 示例5: 便捷函数

```python
from fedcl import run_federated_learning

async def main():
    # 一行代码启动整个系统
    result = await run_federated_learning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        server_config_path="configs/server_demo.yaml",
        client_config_path="configs/client_demo_1.yaml",
        num_clients=5,
        max_rounds=10
    )

    print(f"训练完成！准确率: {result.final_accuracy:.4f}")

if __name__ == "__main__":
    asyncio.run(main())
```

### 示例6: 使用自定义节点ID

```python
from fedcl import FederatedLearning

async def main():
    # 使用有意义的节点ID
    async with FederatedLearning(
        trainer_class=MyTrainer,
        learner_class=MyLearner,
        global_model={"weights": [0.1, 0.2, 0.3]},
        server_id="medical_research_center",        # 自定义服务端ID
        client_ids=[                                 # 自定义客户端ID列表
            "hospital_general",
            "hospital_specialty",
            "clinic_community_A",
            "clinic_community_B"
        ],
        num_clients=4
    ) as fl:
        result = await fl.run(max_rounds=10)
        print(f"训练完成！准确率: {result.final_accuracy:.4f}")

if __name__ == "__main__":
    asyncio.run(main())
```

**自定义节点ID的优势**：
- ✅ **语义清晰**：使用有意义的名称（如 "hospital_general"）比自动生成的 ID（如 "client_1"）更易理解
- ✅ **调试友好**：在日志中更容易识别具体节点
- ✅ **业务对齐**：符合实际业务场景的命名规范
- ✅ **灵活命名**：不受自动生成规则的限制

**更多自定义ID示例**：

```python
# 金融场景
async with FederatedLearning(
    trainer_class=FinanceTrainer,
    learner_class=FinanceLearner,
    global_model=fraud_model,
    server_id="central_risk_management",
    client_ids=["bank_north", "bank_south", "bank_east", "bank_west"],
    num_clients=4
) as fl:
    result = await fl.run(max_rounds=20)

# IoT边缘计算场景
async with FederatedLearning(
    trainer_class=EdgeTrainer,
    learner_class=EdgeLearner,
    global_model=anomaly_model,
    server_id="cloud_coordinator",
    client_ids=["factory_1", "factory_2", "warehouse", "logistics"],
    num_clients=4
) as fl:
    result = await fl.run(max_rounds=15)
```

## 与原有代码的对比

### 原有方式（手动管理所有组件）

```python
# 原有方式：需要手动创建和管理所有组件
async def main():
    # 1. 创建并启动服务端
    server = FederationServer(config)
    await server.initialize_with_trainer(SimpleTrainer, global_model)
    await server.start_server()

    # 2. 创建并启动客户端1
    client1 = FederationClient(config, "client_1")
    await client1.initialize_with_learner(SimpleLearner)
    await client1.start_client()

    # 3. 创建并启动客户端2
    client2 = FederationClient(config, "client_2")
    await client2.initialize_with_learner(SimpleLearner)
    await client2.start_client()

    # 4. 创建协调器
    coordinator = FederationCoordinator(server, FederationConfig())

    # 5. 运行训练
    result = await coordinator.start_federation()

    # 6. 手动清理
    await client1.stop_client()
    await client2.stop_client()
    await server.stop_server()
```

### 新方式（统一入口）

```python
# 新方式：一个类管理所有
async def main():
    async with FederatedLearning(
        trainer_class=SimpleTrainer,
        learner_class=SimpleLearner,
        global_model=global_model,
        server_config_path="configs/server_demo.yaml",
        client_config_path="configs/client_demo_1.yaml",
        num_clients=2
    ) as fl:
        result = await fl.run(max_rounds=10)
```

**优势**:
- 代码量减少 80%
- 自动管理组件生命周期
- 自动处理启动顺序和等待时间
- 自动清理资源
- 配置集中管理

## 内部实现流程

### 初始化流程

```
FederatedLearning.__init__()
├── 加载配置
│   ├── _load_server_config()
│   └── _load_client_config()
└── 保存类和参数

FederatedLearning.initialize()
├── 1. _initialize_server()
│   ├── 创建 FederationServer
│   ├── initialize_with_trainer()
│   └── start_server()
├── 2. 等待服务端启动 (asyncio.sleep(1))
├── 3. _initialize_clients()
│   └── 并发启动所有客户端
│       ├── _create_and_start_client(0)
│       ├── _create_and_start_client(1)
│       └── ...
├── 4. 等待客户端注册 (asyncio.sleep(1))
└── 5. _create_coordinator()
    └── 创建 FederationCoordinator
```

### 训练流程

```
FederatedLearning.run(max_rounds)
├── 检查是否已初始化
│   └── 如果未初始化，调用 initialize()
├── 更新最大轮数配置
└── coordinator.start_federation()
    └── 返回 FederationResult
```

### 清理流程

```
FederatedLearning.cleanup()
├── 停止所有客户端
│   └── asyncio.gather(*[client.stop_client() for client in clients])
├── 停止服务端
│   └── server.stop_server()
└── 重置状态
```

## 配置说明

### FederationConfig

联邦学习配置：

```python
from fedcl import FederationConfig

config = FederationConfig(
    coordinator_id="fed_coordinator",  # 协调器ID
    max_rounds=100,                    # 最大训练轮数
    min_clients=2,                     # 最小客户端数
    client_selection="all",            # 客户端选择策略
    convergence_threshold=0.001,       # 收敛阈值
    patience=5                          # 早停轮数
)
```

### 额外配置

#### trainer_config

传递给 Trainer 的额外配置：

```python
trainer_config = {
    "learning_rate": 0.01,
    "optimizer": "sgd",
    "custom_param": "value"
}

fl = FederatedLearning(
    ...,
    trainer_config=trainer_config
)
```

#### learner_config

传递给 Learner 的额外配置：

```python
learner_config = {
    "batch_size": 32,
    "epochs": 5,
    "device": "cuda"
}

fl = FederatedLearning(
    ...,
    learner_config=learner_config
)
```

## 错误处理

### 自动错误处理

`FederatedLearning` 会自动处理常见错误：

```python
async with FederatedLearning(...) as fl:
    try:
        result = await fl.run()
    except Exception as e:
        # 异常会自动触发清理
        print(f"训练失败: {e}")
# 退出 with 块时自动清理资源
```

### 手动错误处理

```python
fl = FederatedLearning(...)

try:
    await fl.initialize()
    result = await fl.run()
except ConfigurationError as e:
    print(f"配置错误: {e}")
except FederationError as e:
    print(f"联邦学习错误: {e}")
finally:
    await fl.cleanup()
```

## 日志管理

### 自动日志设置

默认启用自动日志：

```python
fl = FederatedLearning(
    ...,
    auto_setup_logging=True  # 默认值
)
```

### 禁用自动日志

```python
fl = FederatedLearning(
    ...,
    auto_setup_logging=False
)

# 手动设置日志
from fedcl.utils.auto_logger import setup_auto_logging
setup_auto_logging(level="DEBUG")
```

## 最佳实践

### 1. 开发阶段

使用便捷函数快速测试：

```python
result = await run_federated_learning(
    MyTrainer, MyLearner,
    global_model,
    "configs/server_demo.yaml",
    "configs/client_demo_1.yaml",
    num_clients=2,
    max_rounds=1  # 快速测试
)
```

### 2. 测试阶段

使用上下文管理器确保资源清理：

```python
async with FederatedLearning(...) as fl:
    result = await fl.run(max_rounds=10)
    assert result.final_accuracy > 0.8
```

### 3. 生产阶段

手动管理以便添加监控和日志：

```python
fl = FederatedLearning(...)

try:
    await fl.initialize()
    logger.info("系统初始化完成")

    result = await fl.run(max_rounds=100)
    logger.info(f"训练完成: {result.final_accuracy}")

    # 保存模型
    save_model(result.final_model)

finally:
    await fl.cleanup()
    logger.info("系统已清理")
```

### 4. 配置管理

使用环境变量和配置文件分离：

```python
import os

config_dir = os.getenv("FEDCL_CONFIG_DIR", "configs")

fl = FederatedLearning(
    ...,
    server_config_path=f"{config_dir}/server.yaml",
    client_config_path=f"{config_dir}/client.yaml"
)
```

## 完整示例

参考 `examples/unified_entry_demo.py` 查看完整的可运行示例。

## 与其他API的关系

MOE-FedCL 提供了多层次的API：

```
Layer 1: FederatedLearning (统一入口)
         └── 整合 Server + Client + Coordinator

Layer 2: FederatedSystemAPI (高层API)
         └── 基于 ServerAPI + MultiClientAPI

Layer 3: ServerAPI, ClientAPI (中层API)
         └── 封装 FederationServer/Client

Layer 4: FederationServer, FederationClient (底层组件)
         └── 直接使用组件
```

**推荐使用顺序**:
1. **快速原型**: `run_federated_learning()` 便捷函数
2. **一般使用**: `FederatedLearning` 类
3. **需要更多控制**: `FederatedSystemAPI`
4. **深度定制**: 直接使用底层组件

## 总结

`FederatedLearning` 统一入口类提供了启动 MOE-FedCL 系统的最简单方式：

✅ **一个类** - 管理服务端、客户端和协调器
✅ **一行代码** - 使用便捷函数快速启动
✅ **配置驱动** - 支持 YAML 文件和代码配置
✅ **自动管理** - 自动处理初始化和清理
✅ **类型安全** - 完整的类型提示和错误处理

从配置文件启动整个联邦学习系统，就是这么简单！
